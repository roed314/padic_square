# Template p-adic fields
{:#template-p-adic-fields}


A "template" p-adic field represents a p-adic field K with only partial information known, such as its prime and absolute degree. For example, the number of extensions of K of a given degree d only depends on d, p, and the absolute inertia and ramification degrees, and so it is useful to have a representation of a field with such limited information.

Currently, the partial information we support is:
- The prime, `p`
- The absolute degree, `(K:Q_p)`
- The absolute inertia degree, `f(K:Q_p)`
- The absolute ramification degree, `e(K:Q_p)`
- The "uniformizer residue class", which is `pi^e/p` where `pi` is a uniformizer; this is well-defined up to a multiple by a `e`th power
- The actual field `K`, as a standard `FldPad` such as is returned by `pAdicField`.


**Contents**
* [Creation](#creation)
* [Invariants](#invariants)
* [Ore's conditions](#ores-conditions)
* [Elements](#elements)
* [Polynomial rings](#polynomial-rings)
* [Polynomials](#polynomials)

## Creation
{:#creation}

<a id="TemplatepAdicField"></a><a id="TemplatepAdicField--noargs"></a>
> **TemplatepAdicField** ()
> 
> -> *FldPadTmpl*
> {:.ret}
{:.intrinsic}

A "template" p-adic field with data given by the parameters.

**Parameters**
- `Prime`
- `Degree`
- `InertiaDegree`
- `RamificationDegree`
- `UniformizerResidue`
- `Actual`

<a id="TemplatepAdicField-2"></a><a id="TemplatepAdicField--RngIntElt"></a>
> **TemplatepAdicField** (p :: *RngIntElt*)
> 
> -> *FldPadTmpl*
> {:.ret}
{:.intrinsic}

The "template" prime `p`-adic field `Q_p`. Equivalent to `TemplatepAdicField(pAdicField(p))`.


<a id="TemplatepAdicField-3"></a><a id="TemplatepAdicField--FldPad"></a>
> **TemplatepAdicField** (K :: *FldPad*)
> 
> -> *FldPadTmpl*
> {:.ret}
{:.intrinsic}

A "template" version of `K`.


<a id="TemplatepAdicCompletion"></a><a id="TemplatepAdicCompletion--Map"></a>
> **TemplatepAdicCompletion** (e :: *Map*)
> 
> -> *FldPadTmpl*
> {:.ret}
{:.intrinsic}

A "template" version of the completion `e`.

**Parameters**
- `Place`
- `Uniformizer`

<a id="TemplatepAdicCompletion-2"></a><a id="TemplatepAdicCompletion--FldRat--etc"></a><a id="TemplatepAdicCompletion--FldRat--RngIntElt"></a><a id="TemplatepAdicCompletion--FldRat--RngInt"></a><a id="TemplatepAdicCompletion--FldNum--etc"></a><a id="TemplatepAdicCompletion--FldNum--any"></a>
> **TemplatepAdicCompletion** (A :: *FldRat*, p :: *RngIntElt*)
> 
> **TemplatepAdicCompletion** (A :: *FldRat*, p :: *RngInt*)
> 
> **TemplatepAdicCompletion** (A :: *FldNum*, p)
> 
> -> *FldPadTmpl*
> {:.ret}
{:.intrinsic}

`A` "template" version of the completion of `A` at `p`.





**Parameters**
- `Uniformizer`

<a id="TemplatepAdicCompletion-3"></a><a id="TemplatepAdicCompletion--FldNum--etc-2"></a><a id="TemplatepAdicCompletion--FldNum--RngIntElt"></a>
> **TemplatepAdicCompletion** (A :: *FldNum*, p :: *RngIntElt*)
> 
> -> *FldPadTmpl*
> {:.ret}
{:.intrinsic}

`A` "template" version of the completion of `A` at the ideal generated by `p` and the `Uniformizer`, if given.

**Parameters**
- `Uniformizer`

## Invariants
{:#invariants}

<a id="HasPrime"></a><a id="HasPrime--FldPadTmpl"></a>
> **HasPrime** (F :: *FldPadTmpl*)
> 
> -> *BoolElt*, *RngIntElt*
> {:.ret}
{:.intrinsic}

True if the prime of `F` is known.


<a id="Prime"></a><a id="Prime--FldPadTmpl"></a>
> **Prime** (F :: *FldPadTmpl*)
> 
> -> *RngIntElt*
> {:.ret}
{:.intrinsic}

The prime `p`.


<a id="HasAbsoluteDegree"></a><a id="HasAbsoluteDegree--FldPadTmpl"></a><a id="HasAbsoluteInertiaDegree"></a><a id="HasAbsoluteInertiaDegree--FldPadTmpl"></a><a id="HasAbsoluteRamificationDegree"></a><a id="HasAbsoluteRamificationDegree--FldPadTmpl"></a>
> **HasAbsoluteDegree** (F :: *FldPadTmpl*)
> 
> **HasAbsoluteInertiaDegree** (F :: *FldPadTmpl*)
> 
> **HasAbsoluteRamificationDegree** (F :: *FldPadTmpl*)
> 
> -> *BoolElt*, *RngIntElt*
> {:.ret}
{:.intrinsic}

True if the absolute degree/inertia degree/ramification degree is known.






<a id="AbsoluteDegree"></a><a id="AbsoluteDegree--FldPadTmpl"></a><a id="AbsoluteInertiaDegree"></a><a id="AbsoluteInertiaDegree--FldPadTmpl"></a><a id="AbsoluteRamificationDegree"></a><a id="AbsoluteRamificationDegree--FldPadTmpl"></a>
> **AbsoluteDegree** (F :: *FldPadTmpl*)
> 
> **AbsoluteInertiaDegree** (F :: *FldPadTmpl*)
> 
> **AbsoluteRamificationDegree** (F :: *FldPadTmpl*)
> 
> -> *RngIntElt*
> {:.ret}
{:.intrinsic}

Absolute degree, inertia degree and ramification degree.






<a id="HasUniformizerResidue"></a><a id="HasUniformizerResidue--FldPadTmpl"></a>
> **HasUniformizerResidue** (F :: *FldPadTmpl*)
> 
> -> *BoolElt*, *FldFinElt*
> {:.ret}
{:.intrinsic}

True if the uniformizer residue of `F` is known.


<a id="UniformizerResidue"></a><a id="UniformizerResidue--FldPadTmpl"></a>
> **UniformizerResidue** (F :: *FldPadTmpl*)
> 
> -> *FldFinElt*
> {:.ret}
{:.intrinsic}

Uniformizer residue, the residue class of pi^e/p where pi is a uniformizer.


<a id="HasResidueClassField"></a><a id="HasResidueClassField--FldPadTmpl"></a>
> **HasResidueClassField** (F :: *FldPadTmpl*)
> 
> -> *BoolElt*, *FldFin*, *Map*
> {:.ret}
{:.intrinsic}

True if the residue class field of `F` is known. If so, returns it and the quotient map.


<a id="ResidueClassField"></a><a id="ResidueClassField--FldPadTmpl"></a>
> **ResidueClassField** (F :: *FldPadTmpl*)
> 
> -> *FldFin*, *Map*
> {:.ret}
{:.intrinsic}

Residue class field and the quotient map.


<a id="HasActual"></a><a id="HasActual--FldPadTmpl"></a>
> **HasActual** (F :: *FldPadTmpl*)
> 
> -> *BoolElt*, *FldPad*, *Map*
> {:.ret}
{:.intrinsic}

True if `F` is associated to an actual field. If so, also returns the it and the embedding into it.


<a id="Actual"></a><a id="Actual--FldPadTmpl"></a>
> **Actual** (F :: *FldPadTmpl*)
> 
> -> *FldPad*, *Map*
> {:.ret}
{:.intrinsic}

The actual field associated to `F`, if there is one.


<a id="Embedding"></a><a id="Embedding--FldPadTmpl--etc"></a><a id="Embedding--FldPadTmpl--FldPad"></a>
> **Embedding** (F :: *FldPadTmpl*, A :: *FldPad*)
> 
> -> *Map*
> {:.ret}
{:.intrinsic}

The embedding of `F` into `A`, which must share the same residue class field.


<a id="HasGlobal"></a><a id="HasGlobal--FldPadTmpl"></a>
> **HasGlobal** (F :: *FldPadTmpl*)
> 
> -> *BoolElt*, *Fld*, *Map*
> {:.ret}
{:.intrinsic}

True if `F` is the completion of a global field. If so, returns the global field and the embedding.


<a id="Global"></a><a id="Global--FldPadTmpl"></a>
> **Global** (F :: *FldPadTmpl*)
> 
> -> *Fld*, *Map*
> {:.ret}
{:.intrinsic}

The global field which `F` is a completion of, and the embedding into it.


<a id="Embedding-2"></a><a id="Embedding--FldPadTmpl--etc-2"></a><a id="Embedding--FldPadTmpl--FldNum--Map"></a><a id="Embedding--FldPadTmpl--FldRat--Map"></a><a id="Embedding--FldPadTmpl--FldRat"></a>
> **Embedding** (F :: *FldPadTmpl*, A :: *FldNum*, e :: *Map*)
> 
> **Embedding** (F :: *FldPadTmpl*, A :: *FldRat*, e :: *Map*)
> 
> **Embedding** (F :: *FldPadTmpl*, A :: *FldRat*)
> 
> -> *Map*
> {:.ret}
{:.intrinsic}


**Note:** The embedding has an inverse defined, but it will enter an infinite loop unless the input can be represented as a finite polynomial in the uniformizer with coefficients representatives of the residue class field (i.`e`. the preimages of the residue map).






**Parameters**
- `Place`: When given, this must be the prime ideal of A corresponding to the completion. By default it is computed from e, but the embedding depends on its generators, so you may get a nicer embedding using the original prime.
- `ResidueMap`: When given, this must be the residue map from the integers of A to the residue class field of F. By default it is computed from Place.
- `Uniformizer`: When given, this must be a uniformizing element for the prime. By default it is computed from Place.

<a id="BinomialValuation"></a><a id="BinomialValuation--FldPadTmpl--etc"></a><a id="BinomialValuation--FldPadTmpl--RngIntElt--RngIntElt"></a>
> **BinomialValuation** (K :: *FldPadTmpl*, n :: *RngIntElt*, k :: *RngIntElt*)
> 
> -> *RngIntElt*
> {:.ret}
{:.intrinsic}

The valuation of `n` choose `k` in `K`.


<a id="ShiftedBinomialResidue"></a><a id="ShiftedBinomialResidue--FldPadTmpl--etc"></a><a id="ShiftedBinomialResidue--FldPadTmpl--RngIntElt--RngIntElt"></a>
> **ShiftedBinomialResidue** (K :: *FldPadTmpl*, n :: *RngIntElt*, k :: *RngIntElt*)
> 
> -> *RngIntElt*
> {:.ret}
{:.intrinsic}

The residue class of `n` choose `k` shifted in `K` down to a unit.


<a id="BinomialResidue"></a><a id="BinomialResidue--FldPadTmpl--etc"></a><a id="BinomialResidue--FldPadTmpl--RngIntElt--RngIntElt"></a>
> **BinomialResidue** (K :: *FldPadTmpl*, n :: *RngIntElt*, k :: *RngIntElt*)
> 
> -> *RngIntElt*
> {:.ret}
{:.intrinsic}

The residue class of `n` choose `k`.


## Ore's conditions
{:#ores-conditions}

<a id="OreConditions"></a><a id="OreConditions--FldPadTmpl--etc"></a><a id="OreConditions--FldPadTmpl--RngIntElt--RngIntElt--RngIntElt"></a>
> **OreConditions** (F :: *FldPadTmpl*, n :: *RngIntElt*, J :: *RngIntElt*, s :: *RngIntElt*)
> 
> -> *BoolElt*
> {:.ret}
{:.intrinsic}

True if there exists an extension of degree `n` of `F` whose ramification polygon has a point `(p^s, J)`.


<a id="OreConditions-2"></a><a id="OreConditions--FldPadTmpl--etc-2"></a><a id="OreConditions--FldPadTmpl--RngIntElt--RngIntElt"></a>
> **OreConditions** (F :: *FldPadTmpl*, n :: *RngIntElt*, J :: *RngIntElt*)
> 
> -> *BoolElt*
> {:.ret}
{:.intrinsic}

True if there exists an extension of degree `n` and discriminant valuation `n+J-1` of `F`.


<a id="OrePossibilities"></a><a id="OrePossibilities--FldPadTmpl--etc"></a><a id="OrePossibilities--FldPadTmpl--RngIntElt--RngIntElt"></a>
> **OrePossibilities** (F :: *FldPadTmpl*, n :: *RngIntElt*, s :: *RngIntElt*)
> 
> -> *BoolElt*
> {:.ret}
{:.intrinsic}

The possible J such that `(F,n,J,s)` satisfy Ore'`s` conditions.


<a id="OrePossibilities-2"></a><a id="OrePossibilities--FldPadTmpl--etc-2"></a><a id="OrePossibilities--FldPadTmpl--RngIntElt"></a>
> **OrePossibilities** (F :: *FldPadTmpl*, n :: *RngIntElt*)
> 
> -> []
> {:.ret}
{:.intrinsic}

The possible J such that `(F,n,J)` satisfy Ore's conditions.


## Elements
{:#elements}


Elements of a template p-adic field are represented by their valuation and a finite sequence of p-adic coefficients, which are elements of the residue class field.

When the actual field is known, we provide maps between the template and actual field (accessible by the `Actual` intrinsic). For each element of the residue class field, we choose a representative in the actual field (specifically, we use the inverse of the map returned by `ResidueClassField` on the actual field). If `R` is the set of representatives, then the sequence of p-adic coefficients may be interpreted as a polynomial with coefficients in `R`. Evaluating this at the uniformizer of the actual field gives an integral element, which is then shifted by the valuation.

<a id="IsCoercible"></a><a id="IsCoercible--FldPadTmpl--etc"></a><a id="IsCoercible--FldPadTmpl--any"></a>
> **IsCoercible** (F :: *FldPadTmpl*, X)
> 
> -> *BoolElt*, Any
> {:.ret}
{:.intrinsic}

Allows coercion into `F` any of the following:
- An element of `F`
- An element of the actual field of `F` (if defined)
- A sequence [c0,c1,...] of p-adic coefficients
- A tuple <v,[c0,c1,...]> of valuation and p-adic coefficients
- The integer 0


<a id="Parent"></a><a id="Parent--FldPadTmplElt"></a>
> **Parent** (x :: *FldPadTmplElt*)
> 
> -> *FldPadTmpl*
> {:.ret}
{:.intrinsic}

The field containing `x`.


<a id="Zero"></a><a id="Zero--FldPadTmpl"></a>
> **Zero** (F :: *FldPadTmpl*)
> 
> -> *FldPadTmplElt*
> {:.ret}
{:.intrinsic}

Zero.


<a id="IsZero"></a><a id="IsZero--FldPadTmplElt"></a>
> **IsZero** (x :: *FldPadTmplElt*)
> 
> -> *BoolElt*
> {:.ret}
{:.intrinsic}

True iff `x` is zero.


<a id="Valuation"></a><a id="Valuation--FldPadTmplElt"></a>
> **Valuation** (x :: *FldPadTmplElt*)
> 
> -> *BoolElt*
> {:.ret}
{:.intrinsic}

The valuation of `x`.


<a id="Actual-2"></a><a id="Actual--FldPadTmplElt"></a>
> **Actual** (x :: *FldPadTmplElt*)
> 
> -> *FldPadElt*
> {:.ret}
{:.intrinsic}

Coerces `x` into the actual field.


<a id="Global-2"></a><a id="Global--FldPadTmplElt"></a>
> **Global** (x :: *FldPadTmplElt*)
> 
> -> *FldElt*
> {:.ret}
{:.intrinsic}

Coerces `x` into the global field.


## Polynomial rings
{:#polynomial-rings}

<a id="PolynomialRing"></a><a id="PolynomialRing--FldPadTmpl"></a>
> **PolynomialRing** (F :: *FldPadTmpl*)
> 
> -> *RngUPol_FldPadTmpl*
> {:.ret}
{:.intrinsic}

The univariate polynomial ring over `F`.


<a id="BaseRing"></a><a id="BaseRing--RngUPol_FldPadTmpl"></a>
> **BaseRing** (R :: *RngUPol_FldPadTmpl*)
> 
> -> *FldPadTmpl*
> {:.ret}
{:.intrinsic}

The base ring.


<a id="HasActual-2"></a><a id="HasActual--RngUPol_FldPadTmpl"></a>
> **HasActual** (R :: *RngUPol_FldPadTmpl*)
> 
> -> *BoolElt*, *RngUPol*, *Map*
> {:.ret}
{:.intrinsic}

True if `R` has an actual ring.


<a id="Actual-3"></a><a id="Actual--RngUPol_FldPadTmpl"></a>
> **Actual** (R :: *RngUPol_FldPadTmpl*)
> 
> -> *RngUPol*, *Map*
> {:.ret}
{:.intrinsic}

The actual ring of `R`.


<a id="HasGlobal-2"></a><a id="HasGlobal--RngUPol_FldPadTmpl"></a>
> **HasGlobal** (R :: *RngUPol_FldPadTmpl*)
> 
> -> *BoolElt*, *RngUPol*, *Map*
> {:.ret}
{:.intrinsic}

True if `R` has a global ring.


<a id="Global-3"></a><a id="Global--RngUPol_FldPadTmpl"></a>
> **Global** (R :: *RngUPol_FldPadTmpl*)
> 
> -> *RngUPol*, *Map*
> {:.ret}
{:.intrinsic}

The global ring associated to `R`.


<a id="Embedding-3"></a><a id="Embedding--RngUPol_FldPadTmpl--etc"></a><a id="Embedding--RngUPol_FldPadTmpl--RngUPol--Map"></a>
> **Embedding** (R :: *RngUPol_FldPadTmpl*, A :: *RngUPol*, m :: *Map*)
> 
> -> *Map*
> {:.ret}
{:.intrinsic}

The embedding of `R` into `A` extending the embedding `m` of base rings.


<a id="Embedding-4"></a><a id="Embedding--RngUPol_FldPadTmpl--etc-2"></a><a id="Embedding--RngUPol_FldPadTmpl--RngUPol-FldPad"></a>
> **Embedding** (R :: *RngUPol_FldPadTmpl*, A :: *RngUPol*[*FldPad*])
> 
> -> *Map*
> {:.ret}
{:.intrinsic}

The embedding of `R` into `A`.


## Polynomials
{:#polynomials}

<a id="IsCoercible-2"></a><a id="IsCoercible--RngUPol_FldPadTmpl--etc"></a><a id="IsCoercible--RngUPol_FldPadTmpl--any"></a>
> **IsCoercible** (R :: *RngUPol_FldPadTmpl*, X)
> 
> -> *BoolElt*, Any
> {:.ret}
{:.intrinsic}

We can coerce the following into `R`:
- Elements of `R`
- Elements of the actual ring of `R` (if defined)
- Polynomials over anything coercible to the base ring of `R`
- Sequences of anything coercible to the base ring of `R`


<a id="Parent-2"></a><a id="Parent--RngUPolElt_FldPadTmpl"></a>
> **Parent** (f :: *RngUPolElt_FldPadTmpl*)
> 
> -> *RngUPol_FldPadTmpl*
> {:.ret}
{:.intrinsic}

The ring containing `f`.


<a id="BaseRing-2"></a><a id="BaseRing--RngUPolElt_FldPadTmpl"></a>
> **BaseRing** (f :: *RngUPolElt_FldPadTmpl*)
> 
> -> *FldPadTmpl*
> {:.ret}
{:.intrinsic}

The base ring of `f`.


<a id="Coefficients"></a><a id="Coefficients--RngUPolElt_FldPadTmpl"></a>
> **Coefficients** (f :: *RngUPolElt_FldPadTmpl*)
> 
> -> []
> {:.ret}
{:.intrinsic}

The coefficients of `f`.


<a id="Coefficient"></a><a id="Coefficient--RngUPolElt_FldPadTmpl--etc"></a><a id="Coefficient--RngUPolElt_FldPadTmpl--RngIntElt"></a>
> **Coefficient** (f :: *RngUPolElt_FldPadTmpl*, i :: *RngIntElt*)
> 
> -> *FldPadTmplElt*
> {:.ret}
{:.intrinsic}

The `i`th coefficient of `f`.


<a id="Degree"></a><a id="Degree--RngUPolElt_FldPadTmpl"></a>
> **Degree** (f :: *RngUPolElt_FldPadTmpl*)
> 
> -> *RngIntElt*
> {:.ret}
{:.intrinsic}

The degree.


<a id="IsZero-2"></a><a id="IsZero--RngUPolElt_FldPadTmpl"></a>
> **IsZero** (f :: *RngUPolElt_FldPadTmpl*)
> 
> -> *BoolElt*
> {:.ret}
{:.intrinsic}

True iff `f` is zero.


<a id="IsEisenstein"></a><a id="IsEisenstein--RngUPolElt_FldPadTmpl"></a>
> **IsEisenstein** (f :: *RngUPolElt_FldPadTmpl*)
> 
> -> *BoolElt*
> {:.ret}
{:.intrinsic}

True iff `f` is Eisenstein.


<a id="Actual-4"></a><a id="Actual--RngUPolElt_FldPadTmpl"></a>
> **Actual** (f :: *RngUPolElt_FldPadTmpl*)
> 
> -> *RngUPolElt*
> {:.ret}
{:.intrinsic}

Coerces `f` into the actual ring.


<a id="Global-4"></a><a id="Global--RngUPolElt_FldPadTmpl"></a>
> **Global** (f :: *RngUPolElt_FldPadTmpl*)
> 
> -> *RngUPolElt*
> {:.ret}
{:.intrinsic}

Coerces `f` into the global ring.


<a id="Extension"></a><a id="Extension--FldPad--etc"></a><a id="Extension--FldPad--RngUPolElt_FldPadTmpl--Map"></a>
> **Extension** (K :: *FldPad*, f :: *RngUPolElt_FldPadTmpl*, m :: *Map*)
> 
> -> *FldPad*
> {:.ret}
{:.intrinsic}

The extension of `K` defined by `f`, with the polynomial embedding `m`.


<a id="Extension-2"></a><a id="Extension--FldPad--etc-2"></a><a id="Extension--FldPad--RngUPolElt_FldPadTmpl"></a>
> **Extension** (K :: *FldPad*, f :: *RngUPolElt_FldPadTmpl*)
> 
> -> *FldPad*
> {:.ret}
{:.intrinsic}

The extension of `K` defined by `f`.


<a id="ActualExtension"></a><a id="ActualExtension--RngUPolElt_FldPadTmpl"></a>
> **ActualExtension** (f :: *RngUPolElt_FldPadTmpl*)
> 
> -> *FldPad*
> {:.ret}
{:.intrinsic}

The extension of the actual field defined by `f`.


