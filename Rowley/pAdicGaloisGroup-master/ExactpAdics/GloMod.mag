import "../Utils.mag": not_implemented, Z;
import "../GloMod.mag": make_primes, number_field;

intrinsic Tower(alg :: PGGAlg_ResEval_Global_Model_D4Tower, L :: PGGFldExact, K :: PGGFldExact) -> []
  {The tower from K to L.}
  require Degree(L,K) eq 4: "L/K must be a D4 extension";
  aK := Actual(K);
  aL := Actual(L);
  af := DefiningPolynomial(aL, aK);
  assert Degree(af) eq 4;
  ars := [aL| r[1] : r in Roots(ChangeRing(af, aL))];
  require #ars eq 2: "L/K must be a D4 extension";
  at := Parent(af) ! [RandomInteger(aK) : i in [1..4]];
  ag := &+[aL| Evaluate(at, r) : r in ars];
  am := MinimalPolynomialAssumingDegree(ag, aK, 2);
  aL1 := certs[1]`Extension where _,_,certs := Factorization(am:Extensions);
  assert Degree(aL1,aK) eq 2;
  aL2 := certs[2]`Extension where _,_,certs := Factorization(ChangeRing(af,aL1):Extensions);
  assert Degree(aL2,aL1) eq 2;
  L1 := PGGFldExact_Make(aL1, K);
  L2 := PGGFldExact_Make(aL2, L1);
  assert Degree(L2,K) eq 4;
  return [K,L1,L2];
end intrinsic;

intrinsic GlobalModel(alg :: PGGAlg_ResEval_Global_Model_PthRoots, f :: PGGPolExact, bm :: PGGGloMod_Fld : TopField:=false, Extendible:=false) -> PGGGloMod, PGGHomGrpPerm
  {Global model.}
  locfld := BaseRing(f);
  locext := TopField;
  glofld := bm`global_field;
  p := Prime(locfld);
  // first check that we have a wild singly ramified extension
  require locext cmpne false: "TopField must be known";
  ok := BaseField(locext) eq locfld;
  if ok then
    d := Degree(locext);
    assert d eq Degree(f);
    ok := InertiaDegree(locext) eq 1;
    if ok then
      ok, n := IsPowerOf(d, p);
    end if;
  end if;
  require ok: "must define a wild singly ramified extension";
  locpol := DefiningPolynomial(locext);
  assert Degree(locpol) eq d;
  // TODO: have checked totally wildly ramified, but not singly ramified
  // SPECIAL CASE: Galois
  pis := Roots(ChangeRing(locpol, locext));
  assert (#pis gt 0) and IsDivisibleBy(d, #pis);
  if #pis eq d then
    pi := pis[1];
    // check singly ramified
    ms := {Z| Valuation(pi - pi2) : pi2 in pis[2..d]};
    require #ms eq 1: "must define a wild singly ramified extension";
    // each pi2 in pis is of the form pi + u pi^m, where v(u) = 0 or OO
    // the set of such u forms a Fp-vector-space of dimension n, on which the Galois group Cp^n acts linearly
    m := Rep(ms);
    resfld, resfldmap := ResidueClassField(locext);
    piress := [resfldmap((pi2 - pi) / (pi^m)) : pi2 in pis];
    assert piress[1] eq 0;
    assert forall{u : u in piress[2..d] | u ne 0};
    assert #SequenceToSet(piress) eq d;
    resfldbase := PrimeField(resfld);
    V0, V0map := VectorSpace(resfld, resfldbase);
    V := sub<V0 | [u@V0map : u in piress]>;
    assert #V eq d;
    assert Dimension(V) eq n;
    pilookup := AssociativeArray(V0);
    for i in [1..d] do
      pilookup[piress[i] @ V0map] := pis[i];
    end for;
    bs := Basis(V);
    assert #bs eq n;
    // for each basis element, compute the subspace generated by the other basis elements
    // the product of the corresponding pis is the norm of pi from the top field down to a degree p subfield
    pi0s := [&*[pilookup[v] : v in sub<V0 | [bs[j] : j in [1..n] | j ne i]>] : i in [1..n]];
    // work with actual exact p-adics for now
    api0s := [Actual(pi0) : pi0 in pi0s];
    alocfld := Actual(locfld);
    alocext := Actual(locext);
    alocppols := [MinimalPolynomialAssumingDegree(api0, alocfld, p) : api0 in api0s];
    assert forall{pol : pol in alocppols | IsEisenstein(pol)};
    locppols := [PolynomialRing(locfld) | pol : pol in alocppols];
    locpexts := [ext<locfld | pol> : pol in locppols];
    alocpexts := [Actual(fld) : fld in locpexts];
    // find glogens such that adjoining pth roots of these gets the local field
    ok, zetap := HasRoot(ChangeRing(CyclotomicPolynomial(p), glofld));
    require ok: "base model must contain pth roots of unity";
    if p eq 2 then
      // since S2=C2, symmetric models suffice when p=2
      gloppols := [GlobalModel(PGGAlg_ResEval_Global_Model_Symmetric_Make(), locppols[i], bm : TopField:=locpexts[i])`global_pol : i in [1..n]];
      assert forall{pol : pol in gloppols | Degree(pol) eq 2};
      glogens := [glofld| (cs[2]*cs[2] - 4*cs[1]*cs[3])/*/(4*cs[3]*cs[3])*/ where cs:=Coefficients(pol) : pol in gloppols];
    else
      // more generally, we need to check that the global base field contains pth roots of unity and use these to construct a Kummer extension
      not_implemented("GlobalModel:", Type(alg), Type(f), Type(bm), "(unless p=2)");
    end if;
    // make the global field by adjoining pth roots
    gloext := glofld;
    gloeltseq := func<x | [x]>;
    gloseqelt := func<x | x[1]>;
    gloroots := [gloext|];
    for i in [1..n] do
      gloext := number_field(PolynomialRing(gloext).1^p - glogens[i] : base:=gloext);//ext<gloext | PolynomialRing(gloext).1^p - glogens[i]>;
      gloeltseq := func<x | &cat[gloeltseq0(y) : y in Eltseq(gloext!x)]> where gloeltseq0:=gloeltseq;
      gloseqelt := func<x | gloext![gloseqelt0(x[j..j+d0-1]) : j in [1..d by d0]]> where d0:=p^(i-1) where d:=p^i where gloseqelt0:=gloseqelt;
      ChangeUniverse(~gloroots, gloext);
      Append(~gloroots, gloext.1);
    end for;
    assert [1..d]@gloseqelt@gloeltseq eq [1..d];
    // find a linear combination of gloroots which generates gloext
    lim := 1;
    while true do
      cs := [Random(1,lim) : i in [1..n]];
      gloextgen := &+[cs[i] * gloroots[i] : i in [1..n]];
      glopol := MinimalPolynomial(gloextgen, glofld);
      if Degree(glopol) eq d then
        break;
      else
        assert lim lt 30;
        lim +:= 1;
      end if;
    end while;
    // get local roots for each base field embedding, and the change-of-basis matrix
    nembs := #bm`embeddings;
    alocrootss := [[Roots(PolynomialRing(alocext).1^p - Actual(emb(glogen)))[1][1] : glogen in glogens] : emb in bm`embeddings];
    V, Vmap := VectorSpace(alocext, alocfld);
    Ms := [Matrix([Vmap(&*[alocroots[i]^x[n+1-i] : i in [1..n]]) : x in CartesianPower([0..p-1], n)]) : alocroots in alocrootss];
    Minvs := [M^-1 : M in Ms];
    // make the global model
    glomod := New(PGGGloMod_PthRoots);
    glomod`base_model := bm;
    glomod`local_field := locext;
    glomod`global_field := gloext;
    glomod`global_pol := glopol;
    if Extendible then
      glomod`embeddings := [map<gloext -> locext | x :-> locext!(((V![Actual(y@emb) : y in gloeltseq(x)])*M)@@Vmap)>  where M:=Ms[i] where emb:=bm`embeddings[i] : i in [1..nembs]];
      glomod`approximations := [func<y,pr | [a(locfld!x,pr) : x in Eltseq((Actual(y)@Vmap)*Minv)]@gloseqelt> where Minv:=Minvs[i] where a:=bm`approximations[i] : i in [1..nembs]];
      make_primes(~glomod);
    end if;
    glomod`global_gens := glogens;
    glomod`global_root_coeffs := cs;
    glomod`global_zetap := zetap;
    glomod`p := p;
    glomod`n := n;
    // Galois groups
    // tW is the image of the regular action of Cp^n on itself; it is transitive, isomorphic to Cp^n, and acts on the conjugates of gloextgen like Cp^n acts on gloroots, and hence is Gal(f)
    tW := sub<SymmetricGroup(d) | [[1+a*di+((b+di0) mod di) where a,b:=Quotrem(j-1,di) : j in [1..d]] where di:=p^i where di0:=p^(i-1) : i in [1..n]]>;
    assert #tW eq d;
    assert Degree(tW) eq d;
    assert IsTransitive(tW);
    W := PGGConj_Raw_Make(f, tW : TopField:=TopField, KnownGroup:=tW);
    W2 := PGGGrpPerm_Raw_Make(tW);
    Whom := PGGHomGrpPerm_Id_Make(W, W2);
    return glomod, Whom;
  end if;
  // GENERAL CASE
  not_implemented("GlobalModel:", Type(alg), Type(f), Type(bm), "(unless Galois)");
end intrinsic;