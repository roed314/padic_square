"Loading polredabs";



function discrete_log(a)
  return Log(a);
end function;

/* is pol irreducible and primitive? */
function is_prim_pol(pol,p)
  m := Degree(pol);
  Fpz<z> := PolynomialRing(GF(p));
  pol := Fpz!pol;
  if not IsIrreducible(pol) then return false; end if;
  xoo := p^m-1;
  pps := [a[1]:a in Factorization(p^m-1)];
  for j in [1..#pps] do
    Fq<a> := ext<GF(p)|pol>;
    if (a^(xoo div pps[j])) eq 1 then
      return false;
    end if;
  end for;
  return true;
end function;


intrinsic unram_pol_jr(m,p) -> .
{}
//function unram_pol_jr(m,p)
  //Fpz<z> := PolynomialRing(GF(p));
  Zx<x> := PolynomialRing(Integers());
  pol := x^m;
  done := false;
  while not done do
    j:=0; s:=1;
    while Coefficient(pol,j) eq (p-1)*s do
      pol -:= s*(p-1)*x^j;
      s := -s;
      j +:= 1;
    end while;
    pol +:= s*x^j;
    if is_prim_pol(pol,p) then 
      done := true; 
    end if;
  end while;
  return pol;
//end function;
end intrinsic;


function conway_or_jr_polynomial(K,n)
  if K eq PrimeRing(K) then
    p := Prime(K);
    if ExistsConwayPolynomial(p,n) then 
      return Polynomial(Integers(),ConwayPolynomial(p,n)); 
    else 
      return unram_pol_jr(n,p);
    end if;
  else
    RK := ResidueClassField(K);
    return Polynomial(K!IrreduciblePolynomial(RK,n));
  end if;
end function;

intrinsic residue_factor(phi) -> .
{}
// irreducible factor of phi over residue class field
// 0 if phi is not a power of an irreducible polynomial over residue class field
  K := CoefficientRing(phi);
  RK, KtoRK := ResidueClassField(K);
  Rphi := Polynomial(RK,phi);
//"Rphi",Rphi;
  if Rphi eq 0 then return 0; end if;
  Rfact := Factorization(Rphi);
//"Rfact",Rfact;
  if #Rfact ne 1 then return 0; end if;
  nu := Rfact[1][1];
  return Polynomial(K,nu);
end intrinsic;


////////////////////////

declare verbose Monge, 6;

intrinsic IsEisensteinForm(phi::RngUPolElt[RngPad]) -> .
{
True, if phi is in Eisenstein form.  If Conway is true the irreducible factor of phi in GF(p) must be a Conway polynomial.
}
  K := CoefficientRing(phi);
  if K ne PrimeRing(K) then return false; end if;
  
  nu := residue_factor(phi);
  if nu eq 0 then return false; end if;
  if not IsMonic(nu) then return false; end if;
  nuexp := Expansion(phi,Polynomial(K,nu));
  if Min([Valuation(a):a in Coefficients(nuexp[1])]) ne 1 then return false; end if;
  for i in [1..#nuexp-1] do
    if &or[Valuation(a) lt 1:a in Coefficients(nuexp[i])]  then return false; end if;
  end for;
  return true;
end intrinsic;

intrinsic EisensteinForm(L::RngPad,K::RngPad) -> .
{
  A generating polynomial phi in K[x] of L in Eisenstein form along with 
  the polynomial nu generating the unramified subextensions of L/K and gamma with phi(gamma) = 0.
}
  vprintf Monge,3: "EisensteinForm of %o\n",L;
//"EF L",L,"K",K;
  Lt<t> := PolynomialRing(L); 
  pi := UniformizingElement(L);

  if InertiaDegree(L,K) eq Degree(L,K) then
    nu := Polynomial(K,conway_or_jr_polynomial(PrimeRing(K),InertiaDegree(L,K)));
    phi :=  DefiningPolynomial(L,K);
    alpha := Roots(Lt!nu-pi:Max:=1)[1][1];
    return nu, nu, alpha;
  elif RamificationIndex(L,K) eq Degree(L,K) then
//"ram";
    // L is totally ramified over K
    phi := DefiningPolynomial(L,K);
//"phi",phi;
    //alpha := Roots(Lt!phi:Max:=1)[1][1];
    return phi, PolynomialRing(K).1, L.1;
  else
    nu := Polynomial(K,conway_or_jr_polynomial(PrimeRing(K),InertiaDegree(L,K)));
    gamma := Roots(Lt!nu-pi:Max:=1)[1][1];
    phi := CharacteristicPolynomial(gamma,K);
    return phi, nu, gamma;
  end if;
end intrinsic;

intrinsic EisensteinForm(f::RngUPolElt[RngPad],K::RngPad) -> .
{
  Given f irreducible, return a polynomial g in Eisenstein form such that K[x]/(g) is isomorphic to 
  the extension of generated by f.
}
  L := CoefficientRing(f);
  RL := ResidueClassField(L);
  f := ChangePrecision(f,Precision(L));

  if not IsMonic(f) then error "EisensteinForm: polynomial",f,"is not monic"; end if;
   
  if IsEisenstein(f) then
    L := TotallyRamifiedExtension(L,f);
    return EisensteinForm(L,K);
  elif 
    IsIrreducible(Polynomial(RL,f)) then
    U := UnramifiedExtension(L,f);
    return EisensteinForm(U,K);
  else  
    factors, _ ,Ls := Factorization(f:Extensions:=true); 
    if #factors gt 1 then error "EisensteinForm: polynomial is not irreducible"; end if;
    return EisensteinForm(Ls[1]`Extension,K);
  end if;
end intrinsic;

intrinsic EisensteinForm(f::RngUPolElt[RngPad]) -> .
{
  Given f in K[x] irreducible, return a polynomial g in Eisenstein form such that K[x]/(g) is isomorphic to 
  the extension of K generated by f.
}
//"EF(f)";
  K := CoefficientRing(f);
  return EisensteinForm(f,K);
end intrinsic;

intrinsic Distinguished(M::SetEnum[RngUPolElt[RngPad]]:nu:=0) -> .
{
  Given a set of reduced polynomials in Eisenstein form, return a distinguished polynomial.
} 
  Rx<x> := Parent(Rep(M));

  if IsEisenstein(Rep(M)) then
    nu := x;
  elif nu eq 0 then
    nu := residue_factor(Rep(M));
  end if;

  L := SetToSequence(M);
  p := Prime(CoefficientRing(L[1]));
 
  function dcompare(f,g)
    fexp := Expansion2(f,nu);
    gexp := Expansion2(g,nu);
    for i in [1..#fexp] do
       for k in [1..#fexp[i]] do
          fik := fexp[i][k];
          gik := gexp[i][k];
          fcp := Evaluate(fik,p);
          gcp := Evaluate(gik,p);
          if fcp ne gcp then 
            return fcp-gcp; 
          end if;
       end for;
    end for;
    error "compare trouble";
    return 0;
  end function;

  Sort(~L, dcompare);
  return L[1];
end intrinsic;




/////////////////////////////////////////////////////////////////////////
//Residual Polynomials

intrinsic ResidualPolynomialOfComponentAbs(phi::RngUPolElt,nu::RngUPolElt,alpha::RngPadElt,m::RngIntElt) -> .
{
The residual polynomial of the segment of the ramfication polygon of phi of slope -m and the Hasse Herbrand function of phi at m.  alpha is a root of phi and nu(alpha) a uniformizing element in the extensions generated by alpha.}
          rp, rho := RamificationPoly(phi,alpha);
          LX<X> := Parent(rho);
          L := CoefficientRing(LX);
          nualpha := Evaluate(LX!nu,alpha);
          RL, LtoRL := ResidueClassField(L);
          RLz<z> := PolynomialRing(RL);
          rhom := Evaluate(rho,nualpha^m*X);
          cont := Minimum([Valuation(a) : a in Coefficients(rhom)]);
          rdpc := rhom div nualpha^cont;
          Sm := &+[z^i*LtoRL(Coefficient(rdpc,i)): i in [0..Degree(rdpc)]];
          return Sm, cont;
end intrinsic;

intrinsic ResidualPolynomial(phi::RngUPolElt,nu::RngUPolElt,alpha::RngPadElt) -> .
{
The residual polynomials of the segments of the ramfication polygon of phi.
alpha is a root of phi and nu(alpha) a uniformizing element in the extensions generated by alpha.}
          rp, rho := RamificationPoly(phi,alpha);
          LX<X> := Parent(rho);
          L := CoefficientRing(LX);
          nualpha := Evaluate(nu,alpha);
          RL, LtoRL := ResidueClassField(L);
          RLz<z> := PolynomialRing(RL);

          slopes := Reverse([-m:m in LowerSlopes(rp)]);
          vertices := Reverse(LowerVertices(rp));
          A := [];

          for l in [1..#slopes] do
            m := slopes[l];
            i := vertices[l][1];
            vri := vertices[l][2];
            j := Integers()!vertices[l+1][1];
            vrj := Integers()!vertices[l+1][2];
            t := Numerator(m);
            d := Denominator(m);
            a := &+[LtoRL(Coefficient(rho,(k*d+j)) div nualpha^(vrj-k*t))*z^k: k in [0..Integers()!((i-j)/d)]];
            Append(~A,a);
          end for;
          return A;

          rhom := Evaluate(rho,nualpha^m*X);
          cont := Minimum([Valuation(a) : a in Coefficients(rhom)]);
          rdpc := rhom div nualpha^cont;
          Sm := &+[z^i*LtoRL(Coefficient(rdpc,i)): i in [0..Degree(rdpc)]];
          return Sm, cont;
end intrinsic;


intrinsic ResidualPolynomial(phi:absolute:=false) -> .
{
The residual polynomials of the segments of the ramfication polygon of phi.
}

  if IsEisenstein(phi) then
    nu := Parent(phi)![0,1];
    K<alpha> := TotallyRamifiedExtension(CoefficientRing(phi),phi);
    return ResidualPolynomial(phi,nu,alpha);
  elif absolute then
    psi, nu, alpha := EisensteinForm(phi); 
    return ResidualPolynomial(psi,nu,alpha);
  else  
    _ , nu, alpha := EisensteinForm(phi); 
    pi := Evaluate(nu,alpha);
    psi := CharacteristicPolynomial(pi);
    K := CoefficientRing(psi);
    psi := ChangePrecision(psi,Precision(K));
    L := TotallyRamifiedExtension(K,psi);
    X := Polynomial(K,[0,1]);
    return ResidualPolynomial(psi,X,L.1);
  end if;
end intrinsic;

intrinsic ResidualPolynomialClasses(phi::RngUPolElt:with_trans:=false,conjugates:=false) -> .
{The residual polynomial classes of an Eisenstein polynomial phi}

      if not IsEisenstein(phi) then
        conjugates := true;
        _ , nu, alpha := EisensteinForm(phi); 
        pi := Evaluate(nu,alpha);
        phi := CharacteristicPolynomial(pi);
      end if;

      Kx<x> := Parent(phi);
      K := CoefficientRing(phi);
      RK, KtoRK := ResidueClassField(K);
      pi := UniformizingElement(K);
      n := Degree(phi);
      
      function residual_polynomial_classes_sub(phi,with_trans)
        invA := {};
        for delta in RK do
          if delta ne 0 then
            deltaK := K!delta;
            phidelta := Kx!([Coefficient(phi,i)*deltaK^(n-i) : i in [0..n]]);
            if with_trans then
              Include(~invA,<ResidualPolynomial(phidelta),phidelta,delta>);
            else
              Include(~invA,ResidualPolynomial(phidelta));
            end if;
          end if;
        end for;
        return invA;
      end function;

      if not conjugates then
        return residual_polynomial_classes_sub(phi,with_trans);
      else
        invA := {};
        gaut, maut := AutomorphismGroup(K);
        aut := [ maut(tau) : tau in gaut ];
        for tau in aut do
          vprintf Monge,1: "ResidualPolynomialClasses: %o |-> %o\n",KtoRK(K.1),KtoRK(tau(K.1));
          tauphi := Kx![ tau(c): c in Coefficients(phi)]; 
          invA join:= residual_polynomial_classes_sub(tauphi,with_trans);
        end for;
        return invA;
      end if;
end intrinsic;

intrinsic PolynomialCompareLog(f,g) -> .
{Compare two polynomials over a local field of the same degree by comparing the discrete logarithms of the coefficients and using lexicographic ordering with leading coefficient first.}
  if Degree(f) ne Degree(g) then error "ResidualPolynomialCompare: Polynomials must be of the same degree."; end if;
  for i := Degree(f) to 0 by -1 do
    a := Coefficient(f,i); b := Coefficient(g,i);
    if a eq 0 and b ne 0 then 
      return -1;
    elif b eq 0 and a ne 0 then 
      return 1;
    elif a ne 0 and b ne 0 and a ne b then
      c := discrete_log(a); d := discrete_log(b);
      return c-d;
    end if;
  end for;
  return 0;
end intrinsic;

intrinsic ResidualPolynomialCompare(A,B) -> .
{
Return 1 if A>B, -1 if A<B, 0 otherwise
}
  if #A ne #B then error "ResidualPolynomialCompare: Lists of residual polynomials must be of the same length."; end if;
  for i in [1..#A] do
    c := PolynomialCompareLog(A[i],B[i]);
    if c ne 0 then return c; end if;    
  end for;  
  return 0;
end intrinsic;

intrinsic ResidualPolynomialDistinguished(phi::RngUPolElt:conjugates:=false) -> .
{
The distinguished (minimal) representative of the residual polynomial class of an Eisenstein polynomial phi
along with the Eisenstein polynomials that yield the distinguished representative.
}
      if not IsEisenstein(phi) then
        conjugates := true;
        _ , nu, alpha := EisensteinForm(phi); 
        pi := Evaluate(nu,alpha);
        phi := CharacteristicPolynomial(pi);
      end if;

      K := CoefficientRing(phi);
      piK := UniformizingElement(K);
      Kx<x> := PolynomialRing(K);
      phi := ChangePrecision(phi,Precision(K));
      L<alpha> := TotallyRamifiedExtension(K,phi);
      rp, rho := RamificationPoly(phi,alpha);
      slopes := Reverse([-m:m in LowerSlopes(rp)]);
      vertices := Reverse(LowerVertices(rp));
      Fq, KtoFq := ResidueClassField(K);
      Fqz<z> := PolynomialRing(Fq);
      q := #Fq;
      xi := PrimitiveElement(Fq);

      vprintf Monge, 2: "ResidualPolynomialDistinguished: conjugates %o\n",conjugates;  
      vprintf Monge, 4: "ResidualPolynomialDistinguished: %o with slopes %o\n",phi,slopes;  

        function residual_polynomial_distinguished_sub(phi);
          L<alpha> := TotallyRamifiedExtension(K,phi);
          LX<X> := PolynomialRing(L);
          slopes := Reverse([-m:m in LowerSlopes(rp)]);
          vertices := Reverse(LowerVertices(rp));
          A := ResidualPolynomial(phi);
          g := 0;
          Delta := 1;
          x_base := [0];
          for i in [1..#slopes] do
            n := Degree(A[i]);
            m := slopes[i];
            t := Numerator(m);
            d := Denominator(m);
            g := g+(d-t)*n;
            for j := n to 0 by -1 do
              Aij := Coefficient(A[i],j);
              vprintf Monge, 4: "ResidualPolynomialDistinguished: slope %o, %o-th monomial %o\n",slopes[i],j,Aij;
              if Aij ne 0 then
                a := discrete_log(Aij) mod (q-1);
                D := (Delta*((t-d)*j+g)) mod (q-1);
                if D ne 0 then 
                  b,s,_ := Xgcd(D,q-1);
                  new_Delta := Lcm(Delta,(q-1) div b);
                  minexp := q;
                  for xij in x_base do
                      J := a+xij*((t-d)*j+g);                    
                      r := J mod b;
                      k := J div b;
                      x := (xij-k*s*Delta) mod (q-1);
                      vprintf Monge, 2: "ResidualPolynomialDistinguished:    solutions %o + n*%o\n",x,Delta;  
                      if r lt minexp then
                        minexp := r;
                        new_x_base := [x];
                      elif r eq minexp then
                        Append(~new_x_base,x);
                      end if;
                  end for;
                  Delta := new_Delta;
                  x_base := new_x_base;
                end if;
              end if; 
            end for;
          end for;
          return x_base, Delta;
       end function;

       function residual_polynomial_phis(thisphi,s_base,s_diff)
          vprintf Monge, 2: "ResidualPolynomialDistinguished:    final difference: %o\n",s_diff;  
          minphis := [];
          for sb in s_base do
            s := sb;
            repeat
              s := (s+s_diff) mod (q-1);
              deltaK := K!(xi^s);
              phidelta := Kx!([Coefficient(thisphi,i)*deltaK^(Degree(thisphi)-i) : i in [0..Degree(thisphi)]]);
              Include(~minphis,<ResidualPolynomial(phidelta),phidelta>);
            until s eq sb; 
          end for;
          vprintf Monge, 4: "ResidualPolynomialDistinguished:    #phis = %o\n",#minphis;  
          return minphis;
       end function;

       if not conjugates then
         base, delta := residual_polynomial_distinguished_sub(phi);
         As := residual_polynomial_phis(phi,base,delta);
         phis := [a[2]: a in As | a[1] eq As[1][1]];
         return As[1][1],phis;
       else
         As := [];
         gaut, maut := AutomorphismGroup(K);
         aut := [ maut(tau) : tau in gaut ];
         for tau in aut do
           vprintf Monge,1: "ResidualPolynomialDistinguished: %o |-> %o\n",KtoFq(K.1),KtoFq(tau(K.1));
           tauphi := Kx![tau(c): c in Coefficients(phi)];
           base, delta := residual_polynomial_distinguished_sub(tauphi);
           As cat:= residual_polynomial_phis(tauphi,base,delta);
         end for;           
         Sort(~As,func<x,y|ResidualPolynomialCompare(x[1],y[1])>);
         vprint Monge, 2: "ResidualPolynomialDistinguished: sorted",[a[1] : a in As];  
       end if;
       philogs := [<discrete_log(KtoFq(ConstantCoefficient(a[2])/piK)),a[2]>: a in As | a[1] eq As[1][1]];
       minlog := Min([a[1] : a in philogs]);
       phis := [a[2]:a in philogs|a[1] eq minlog];
       return As[1][1],phis;
end intrinsic;

intrinsic Expansion(f::RngUPolElt,nu::RngUPolElt) -> .
{
  The coefficients of the nu-expansion of f as a list.
}
  expansion := [];
  l := 0;
  repeat
    l +:= 1;
    a := f mod nu;
    Append(~expansion,a);
    f := (f-a) div nu;
  until f eq 0;
  return expansion;
end intrinsic;

intrinsic Contraction(L::SeqEnum,nu::RngUPolElt) -> .
{
  Contraction(Expansion(f,nu),nu) = f
}
  return &+[L[i]*nu^(i-1) : i in [1..#L]];
end intrinsic;

intrinsic IsMono(f::RngUPolElt) -> .
{true if the polynomial f is a monomial}
  R := CoefficientRing(f);
  mono := 1 eq &+[1: a in Eltseq(f) | a ne 0];
  if not mono then 
    return false; 
  elif R eq BaseRing(R) then 
    return mono;
  else 
    coeff := &+[a : a in Eltseq(f)];
    ret := 1 eq &+[1: a in Eltseq(coeff) | a ne 0];
    return ret;
  end if;
end intrinsic;


intrinsic String(f::RngUPolElt:nu:=0,wherenu:=false,Latex:=false) -> .
{
  The nu expansion of f as a string.
}
  if (nu eq 0 and IsEisenstein(f)) or IsEisenstein(f) then
    nu := Parent(f).1;
    if wherenu then wherenu := false; Latex := true; end if;
  elif nu eq 0 then
//"rf",residue_factor(f);
    nu := residue_factor(f);
  end if;
 
  R := CoefficientRing(f);
  QR<a> := quo<R|UniformizingElement(R)^Precision(R)>;
  QRx<x> := PolynomialRing(QR);
 
  function tex(g)
    t := Sprintf("%O",QRx!g,"Latex");
    if IsMono(g) then 
      return t;
    else 
      return "(" cat t cat ")";
    end if;
  end function;

  nuexp := Expansion(f,nu);
  
  if wherenu then
    s := Sprintf("\\(\\nu^{%o} + ",#nuexp-1);
  elif Latex then
    s := Sprintf("\\(%o^{%o} + ",tex(nu),#nuexp-1);
  else 
    s := Sprintf("(%o)^%o + ",nu,#nuexp-1);
  end if;
  for j in [1..#nuexp-2] do
    i := #nuexp-j;
    if nuexp[i] ne 0 then
      if i eq 2 then
        if wherenu then
          s cat:= Sprintf("%o\\nu + ",tex(nuexp[2]));
        elif Latex then
          s cat:= Sprintf("%o %o + ",tex(nuexp[2]),tex(nu));
        else
          s cat:= Sprintf("(%o)*(%o) + ",QRx!nuexp[2],QRx!nu);
        end if;
      else
        if wherenu then
          s cat:= Sprintf("%o\\nu^{%o} + ",tex(nuexp[i]),i-1);
        elif Latex then
          s cat:= Sprintf("%o %o^{%o} + ",tex(nuexp[i]),tex(nu),i-1);
        else
          s cat:= Sprintf("(%o)*(%o)^%o + ",QRx!nuexp[i],QRx!nu,i-1);
        end if;
      end if;
    end if;
  end for;
  if wherenu then
    s cat:= Sprintf("%o\\) where \\(\\nu = %O\\)",tex(nuexp[1]),QRx!nu,"Latex");
  elif Latex  then
    s cat:= Sprintf("%o\\)",tex(nuexp[1]));
  else
    s cat:= Sprintf("%o",QRx!nuexp[1]);
  end if;
  return s;
end intrinsic;

intrinsic Expansion2(f::RngUPolElt,nu::RngUPolElt:limit:=0) -> .
{
  The nu-expansion of f such that its coefficients are given as p expansions and the nu-expansion of f.
}
  if limit eq 0 then limit := Precision(CoefficientRing(f)); end if;
//"f",f,"nu",nu;  
  //Kx<x> := Parent(f);
  //K := CoefficientRing(f);
//"Expansion2","f",Parent(f),"nu",Parent(nu);

  Zx<x> := PolynomialRing(Integers()); 

  nuexp := Expansion(f,nu);
  p := Prime(CoefficientRing(f));
  //pi := UniformizingElement(K);

  if Degree(nu) gt 1 then
    expansion := [Zx!a : a in nuexp];
  else
    expansion := [Zx!Eltseq(ConstantCoefficient(a)): a in nuexp];
  end if;

  //expansion := nuexp;

  expexp := [];
  
  for g in expansion do
    h := g;
    gel := [];
    c := 0;
    while h ne 0 and c le limit do 
      Append(~gel,h mod p);
      h := h div p;
     c := c+1;
    end while;
    Append(~expexp,gel);
  end for;
  maxlen := Maximum([#gel:gel in expexp] cat [limit]); 
  for i in [1..#expexp] do 
    expexp[i] := expexp[i] cat [0:k in [1..maxlen-#expexp[i]+1]];
  end for;
//"expexp",Parent(expexp); 
//"nuexp",Parent(nuexp); 
  return expexp, nuexp;
end intrinsic;

intrinsic Contraction2(L::SeqEnum,nu::RngUPolElt) -> .
{
  Contraction2(Expansion2(f,nu),nu) = f
}
  Rx<x> := Parent(nu);
  R := CoefficientRing(nu);
  p := Prime(R);
  if R eq PrimeRing(R) then 
    return Rx!(&+[ &+[ p^(j-1)*L[i][j] : j in [1..#L[i]] ]*nu^(i-1) : i in [1..#L]]);
  elif Degree(nu) eq 1 then
//"p",Parent(L);
////"L",L;
    return Rx!([ &+[ p^(j-1)*Evaluate(L[i][j],R.1) : j in [1..#L[i]] ]: i in [1..#L]]);
  else
    error "not implemented yet";
  end if;  
end intrinsic;


intrinsic RamificationPoly(phi::RngUPolElt,alpha::RngPadElt) -> .
{Absolute ramification polygon and polynomial phi(alpha+x) of a polynomial phi in Eisenstein form,
where alpha is a root of phi.}

        L:=Parent(alpha);
        Lx<x> := PolynomialRing(L);
//"phi",Parent(phi);
//"x+alpha",Parent(x+alpha);
        rho:=Evaluate(Lx!phi,x + alpha); 
        ramification_polygon := NewtonPolygon(rho);
        return ramification_polygon,rho;
end intrinsic;

intrinsic RamificationPoly(phi::RngUPolElt) -> .
{Ramification polygon and polynomial phi(alpha+x) of a polynomial phi.}
//"EF 5";    
        phi, nu, alpha := EisensteinForm(phi);
        return RamificationPoly(phi,alpha);
end intrinsic;

intrinsic RamificationPolyAbs(phi::RngUPolElt) -> .
{Absolute ramification polygon and polynomial phi(alpha+x) of a polynomial phi.}
//"EF 5";    
        phi, nu, alpha := EisensteinForm(phi,PrimeRing(CoefficientRing(phi)));
        return RamificationPoly(phi,alpha);
end intrinsic;




///////////////////////////////////////////////////////////////
function pol_red_padic_sub(Phi,nu,alpha,psi01)
//"pol_red_padic psi01",psi01,"Parent(nu)",Parent(nu);
// Phi in K[x]
// nu in K[x] generates unramified subextension of L = K[x]/(Phi) = K(alpha)  
// Phi(alpha) = 0
// psi01 desired constant coefficient mod pi^2
//"=======================================================";
//"PolRedPadic(Phi,nu,alpha,psi01)";
//"psi01",psi01;
        vprint Monge,5:"PolRedPadic: reduction of",String(Phi:nu:=nu);
        // these stay fixed
        n := Degree(Phi);
        f := Degree(nu);
        e := n div f;
        
        Kx<x> := Parent(Phi);
        K := CoefficientRing(Kx);

        p := Prime(K);
        Zp := PrimeRing(K);
        RK, KtoRK := ResidueClassField(K);
        RKs, RKstoRK := UnitGroup(RK);
        RKz<z> := PolynomialRing(RK);

        L := Parent(alpha);

        Lt<t> := PolynomialRing(L);
        RL, LtoRL := ResidueClassField(L);
        Fp := BaseField(RL);
        RLs, RLstoRL := UnitGroup(RL);
        psi01R := LtoRL(psi01);
        xi := RL.1; // primitive element
        Pi := Evaluate(Polynomial(L,nu),alpha);        
       
        function is_iso(S)
          FB := Basis(RL,RK);  
          FL := [Eltseq(Evaluate(S,b)):b in FB];
          FM := Matrix(FL);
          return Rank(FM) eq #FB; 
        end function;

        // for m high enough we can set coefficients to 0       
       
        Wm := AssociativeArray(); // 'HasseHerbrand' of m, these do not change with phi
        rp, rho := RamificationPoly(Phi,alpha);
        
        slopes := LowerSlopes(rp); // slopes := slopes[2..#slopes]; // remove infinite slope
        vprintf Monge,2: "PolRedPadic: Ramification polygon %o with slopes %o\n", LowerVertices(rp), slopes;
        intslopes := [Floor(s):s in slopes | Abs(s) lt Precision(PrimeRing(K))];
        
        max_m := Integers()!-Minimum(intslopes)+2;
        m := max_m;
        Sm, pre_w := ResidualPolynomialOfComponentAbs(Phi,nu,alpha,m);
        Wm[m] := pre_w;
        vprint Monge,2: "PolRedPadic: m =",m,", w(m) =",Wm[m],", Sm =",Sm;
        repeat
          pre_w := Wm[m];
          m := m-1;
          Sm, Wm[m] := ResidualPolynomialOfComponentAbs(Phi,nu,alpha,m);
          vprint Monge,2: "PolRedPadic: m =",m,", w(m) =",Wm[m],", Sm =",Sm;
        until not is_iso(Sm) or not Wm[m+1]-Wm[m] eq 1 or Wm[m] eq 0;
        easystart := m+2; 
        easylimit := Wm[easystart] div e + 1;
        
        vprint Monge,1:"PolRedPadic: easy reduction starts with m =",easystart,"; i.e. modulo pi ^",easylimit;
 
        function easyreduce(phi)
          m := easystart;
          nuexp := Expansion2(phi,nu : limit := easylimit);
          vprint Monge,4:"PolRedPadic: easy reduction start m =",easystart," modulus p ^",easylimit;
          repeat
            def, wm := IsDefined(Wm,m);
            if not def then wm := Wm[max_m]+m-max_m; end if;
            i := wm mod e;
            k := wm div e;
            nuexp[i+1][k+1] := 0;
            vprintf Monge,5:"PolRedPadic:   m = %o : setting phi*_(%o,%o) = %o to 0\n",m,i,k,nuexp[i+1][k+1];
            // printf "PolRedPadic:   m = %o : setting phi*_(%o,%o) = %o to 0\n",m,i,k,nuexp[i+1][k+1];
            vprintf Monge,4:"PolRedPadic:   still isomorphic %o\n", HasRoot(Lt!Contraction2(nuexp,nu));
            m := m+1;
          until k gt easylimit or k ge Precision(Zp);
          newphi := Contraction2(nuexp,nu);
          vprintf Monge,4:"PolRedPadic:   still isomorphic %o\n", HasRoot(Lt!newphi);
          return newphi;
        end function;
       
        // reduction of constant coefficient mod pi^2
        vprint Monge,2:"PolRedPadic: reduction with alpha -> alpha + theta * nu(alpha)";
        nuexp2, nuexp := Expansion2(Phi,nu : limit := easylimit);
        phi0 := nuexp[1];
        phi0alpha := Evaluate(Lt!phi0,alpha); 
        nualpha := Evaluate(Lt!nu,alpha);
        eta := LtoRL((nualpha^e) div p);
        S1, r1 := ResidualPolynomialOfComponentAbs(Phi,nu,alpha,1);
        S1eta := eta*S1;
        vprint Monge,1: "PolRedPadic: m = 1 , w(1) =",r1,", eta*S1 =",S1eta;
        if Valuation(alpha) eq 0 then
          gamma := alpha;
        else 
          gamma := L!xi;
        end if; 
        phi01 := RL!Evaluate(nuexp2[1][2],gamma);
        new_phis := {};
        Thetas := [r[1]:r in Roots(S1eta-(phi01-psi01R))];
        vprintf Monge,2:"PolRedPadic:   transforming phi*_(0,1) from %o to %o\n",phi01,psi01R;
        if Thetas eq [] then
          error "PolRedPadic: reduction step slope 1 failed";
        end if;
//"Thetas",Thetas;
        for theta in Thetas do
          vprintf Monge,2:"PolRedPadic:     transformation alpha -> alpha + (%o)*nu(alpha)\n",theta;
          new_beta := alpha+(L!theta)*nualpha; 
//"new_beta",new_beta;
          new_phi := CharacteristicPolynomial(new_beta,K);
          Include(~new_phis,<new_phi,new_beta>);
//"gamma";
          vprint  Monge,2:"PolRedPadic:     now phi*_(0,1) =",RL!Evaluate(Expansion2(new_phi,nu)[1][2],gamma);
          if not RL!Evaluate(Expansion2(new_phi,nu)[1][2],gamma) eq psi01R then
             error "PolRedPadic: reduction step m=1 failed";
          end if;
        end for;
        M := new_phis;
// !!
        vprintf Monge,1:"PolRedPadic: m=%o reduced are isomorphic %o\n",1,[HasRoot(Polynomial(L,psi[1])):psi in M];
        // other levels
        for m in [2..easystart-1] do
           vprintf Monge,2:"PolRedPadic: m = %o, reduction with alpha -> alpha + theta * nu(alpha)^%o\n",m,m;
           new_M := {};
           for phiandbeta in M do
              phi := phiandbeta[1]; beta := phiandbeta[2];
              nuexp2, nuexp := Expansion2(phi,nu : limit := easylimit);
              
              phi0 := -nuexp[1];
              phi0beta := Evaluate(phi0,beta); 
              nubeta := Evaluate(nu,beta);
              eta := LtoRL(nubeta^e/p);
              vprint Monge,5:"PolRedPadic:   reducing f =",String(phi:nu:=nu);
              Sm, wm := ResidualPolynomialOfComponentAbs(phi,nu,beta,m);
              i := wm mod e;
              k := wm div e;
              vprint Monge,1:"PolRedPadic:   w(m) =",wm,", eta =",eta,", Sm =",Sm;

              phisik := nuexp2[i+1][k+1];
              vprint Monge,2:"PolRedPadic:   improving phi*_(",i,",",k,") =",phisik;
              //G phisikbeta := LtoRL(Evaluate(phisik,beta));
              if Valuation(beta) eq 0 then
                gamma := LtoRL(beta);
              else
                gamma := RL.1;
              end if;
              phisikbeta := Evaluate(phisik,LtoRL(gamma));
              
              //FB := Basis(RL,RK);
              FB := Basis(RL,Fp); // !!
              FL := [Eltseq(Evaluate(eta^k*Sm,b)):b in FB]; 
              FM := Matrix(FL);
             
              // reduce phisikbeta by the image of eta^j*Sm 
              Mecho := EchelonForm(Matrix([Reverse(r): r in RowSequence(FM)]));
              vdelta := Vector(Reverse(Eltseq(phisikbeta)));
              jB := 1;
              iB := 1;
              done := false;
              while iB le #FB and not done do // row counter
                while Mecho[iB][jB] eq 0 and not done do
                  if jB lt #FB then jB := jB + 1; else done := true; end if;
                end while;
                if not done then
                  vb := Vector(Mecho[iB]);
                  ab := vdelta[jB]/vb[jB];
                  vdelta := vdelta - ab*vb;
                  iB := iB + 1;
                end if;
              end while;
              delta := RL!Reverse(Eltseq(vdelta));
              // find coefficient for reduction
              sol, kernel  := Solution(Matrix(FM),Vector(Eltseq(phisikbeta-delta)));
              theta := RL!Eltseq(sol);
              vprint Monge,2:"PolRedPadic:   theta",theta;
              Thetas := [theta+RL!Eltseq(a):a in Set(Kernel(FM))];
              vprintf Monge,2:"PolRedPadic:   thetas %o\n",Thetas;
              new_phis := {};
              for theta in Thetas do
                vprintf Monge,2:"PolRedPadic:     transformation alpha -> alpha + (%o)*nu(alpha)^%o\n",theta,m;
                new_beta := beta+(L!theta)*nubeta^m;
                new_phi := CharacteristicPolynomial(new_beta,K);
                Include(~new_phis,<new_phi,new_beta>);
                vprint Monge,4:"PolRedPadic:     now phi*_(",i,",",k,") =",Expansion2(new_phi,nu)[i+1][k+1];
                //vprintf Monge,5:"PolRedPadic:     phi(beta) = phi(%o) = %o\n",new_beta,Evaluate(new_phi,new_beta);
              end for;
              new_M join:= new_phis;
            end for;
            M := new_M;
            vprintf Monge,1:"PolRedPadic: m=%o reduced are isomorphic %o\n",m,[HasRoot(Polynomial(L,psi[1])):psi in M];
          end for;
        M := {easyreduce(phibeta[1]): phibeta in M};
        vprintf Monge,1:"PolRedPadic: easy reduced are isomorphic %o\n",[HasRoot(Polynomial(L,psi)):psi in M];
        return M;

end function;


intrinsic PolRedPadicTame(phi::RngUPolElt) -> .
{Krasner-Monge reduction of a polynomial }
//"Tame";
  K := CoefficientRing(phi);
  p := Prime(K);
  psi := DefiningPolynomial(K);
  e0 := Degree(phi);
  if (e0 mod p) eq 0 then
    error "PolRedPadicTame works for tamely ramified extensions only";
  end if;
  Kx<x> := PolynomialRing(K);
  pi := UniformizingElement(K);
  U, KtoU := ResidueClassField(K);
  xi := PrimitiveElement(U);
  phi0 := ConstantCoefficient(phi);
  phi01 := KtoU(phi0 div pi);
  l := discrete_log(phi01);
  b := Gcd(e0,#U-1);
  r := l mod b;
  psi := x^e0+pi*K!(xi^r);
//"psi",psi;
  return psi;
end intrinsic;

intrinsic PolRedPadicTame(Phi::RngUPolElt,nu::RngUPolElt,alpha:distinguished:=true,conjugates:=false) -> .
{}
//"Tame3";
//"Phi",Phi;
//"deg(nu)",Degree(nu);
  K := CoefficientRing(Phi);
//"K",K;
//"conjugates",conjugates;
  Kx<x> := PolynomialRing(K);
  L := Parent(alpha);
  Ly<y> := PolynomialRing(L);
  pi := UniformizingElement(K);
  p := Prime(L);
  phi := DefiningPolynomial(L);
  Lur<a> := CoefficientRing(phi);
  Lurx<x> := PolynomialRing(Lur);
  U, LurtoU := ResidueClassField(Lur);
  e0 := Degree(phi);
  if conjugates then
    gaut, maut := AutomorphismGroup(Lur);
    aut := [ maut(tau) : tau in gaut ];
//"aut",aut;
    M := {};
    for tau in aut do
      vprintf Monge,1: "PolRedPadic: %o |-> %o\n",Lur.1,tau(Lur.1);
      tauphi := Lurx![tau(c): c in Coefficients(phi)];
      psi := PolRedPadicTame(tauphi);
//"psi",psi; "#roots", #Roots(Ly!psi);
      if Degree(nu) eq 1 then
//"one";
        Include(~M,psi);
      else
//"tauphi",tauphi;
        psi0 := ConstantCoefficient(psi);
        psi01 := LurtoU(psi0 div pi);
        psi01coeffs := Eltseq(psi01);
        Psi01 := Kx!psi01coeffs;
        Psi := Kx!nu^e0+Psi01*p;
//"Psi",Psi; "#roots", #Roots(Ly!Psi);
        Include(~M,Psi);
      end if;
    end for;
//"M",M;  
  else
    M := {PolRedPadicTame(phi)};    
  end if;
  if distinguished then
    PSI := Distinguished(M:nu:=nu);
//"after dist nuexp",Expansion(PSI,nu);
//"PSI",PSI;
    return PSI;
  else
    return M;
  end if;
end intrinsic;

intrinsic PolRedPadic(L::RngPad:distinguished:=true) -> .
{Krasner-Monge reduced polynomial phi such that L = Zp[x]/(phi)}
//"PolRedPadic(L)";
  p := Prime(L);
  Lt<t> := PolynomialRing(L); 
  Zp := PrimeRing(L);
  Zpx<x> := PolynomialRing(Zp);
  //U := BaseRing(L);
  //Uy<y> := PolynomialRing(U);  
  pi := UniformizingElement(L);
  f := InertiaDegree(L,PrimeRing(L));
  nu := Zpx!conway_or_jr_polynomial(Zp,f);
  gamma := Roots(Lt!nu-pi)[1][1];
// TODO
  psi := DefiningPolynomial(L);
  phi := CharacteristicPolynomial(gamma,Zp);
  n := Degree(phi);
  A, psis := ResidualPolynomialDistinguished(psi:conjugates := true);
  vprint Monge,2:"PolRedPadic: ResidualPolynomialDistinguished",A;
  M := {};
  for psi in psis do
//"PRP(L) EF";
    thisphi, nu, thisalpha := EisensteinForm(psi);
    psi01 := Coefficient(psi,0) div p;
//"2";
    newphis := pol_red_padic_sub(thisphi,Zpx!nu,thisalpha,psi01);
    M join:= newphis;
  end for;
  if distinguished then
    PSI := Distinguished(M);
    vprint Monge,2:"PolRedPadic: reduced is isomorphic is",HasRoot(Polynomial(L,PSI));
    return PSI;
  else
    return M; 
  end if;
end intrinsic;



intrinsic PolRedPadic(Phi::RngUPolElt,nu::RngUPolElt,alpha:distinguished:=true,conjugates:=true) -> .
        {Phi in Zp[x] in Eisenstein Form, Phi(alpha)=0, nu(alpha) uniformizer of Qp(alpha), 
return the Krasner- Monge reduction of Phi}
//"PolRedPadic(Phi,nu,alpha)";
//"conjugates",conjugates;
//"Phi nu alpha",Phi,nu,alpha;
  Kx<x> := Parent(Phi); 
  K := CoefficientRing(Phi);

  L := Parent(alpha);
  Lt<t> := PolynomialRing(L); 

  RL, LtoRL := ResidueClassField(L);
  p := Prime(L);
  U := BaseRing(L);
  Uy<y> := PolynomialRing(U);  
  pi := UniformizingElement(L);
  psi := DefiningPolynomial(L);
  gamma := Roots(Lt!nu-pi)[1][1];
  phi := CharacteristicPolynomial(gamma,BaseRing(U));
  vprintf Monge,1:"PolRedPadic(Phi,%o,alpha): char poly isomorphic is %o\n",nu,HasRoot(Polynomial(L,phi));
  n := Degree(phi);
  A, psis := ResidualPolynomialDistinguished(psi:conjugates := conjugates);
  vprint Monge,2:"PolRedPadic: ResidualPolynomialDistinguished",A;
  M := {};
//"psis",psis;
  for psi in psis do
    vprintf Monge,1:"PolRedPadic(Phi,%o,alpha): distinguished is isomorphic is %o\n",nu,HasRoot(Polynomial(L,psi));
//"PRP(P,n,a) EF";
//"psi",psi;
    thisphi, nu, thisalpha := EisensteinForm(psi,K);
//"thisphi",thisphi;
    vprintf Monge,1:"PolRedPadic(Phi,%o,alpha): Eisenstein form is isomorphic is %o\n",nu,HasRoot(Polynomial(L,phi));
    psi01 := Coefficient(psi,0) div p;
//"1";
    newphis := pol_red_padic_sub(thisphi,Kx!nu,thisalpha,psi01);
    vprintf Monge,1:"PolRedPadic(Phi,%o,alpha): reduced are isomorphic %o\n",nu,[HasRoot(Polynomial(L,psi)):psi in newphis];
    M join:= newphis;
  end for;
  if distinguished then
    PSI := Distinguished(M);
    vprintf Monge,1:"PolRedPadic(Phi,%o,alpha): reduced is isomorphic is %o\n",nu,HasRoot(Polynomial(L,PSI));
    return PSI;
  else
    return M; 
  end if;
end intrinsic;

intrinsic PolRedPadic(Phi::RngUPolElt,K::RngPad:distinguished:=true,conjugates:=true) -> .
{For Phi in O_L irreducible return a Krasner-Monge reduced polynomial Psi such that L[x]/(Phi)=K[x]/(Psi).}
//"PolRedPadic(Phi,K)";
//"conjugates",conjugates;
   p := Prime(K);
   vprintf Monge,2:"PolRedPadic: converting to Eisenstein form\n";
//"PRP(P,K) EF";
//"Phi",Parent(Phi);
//"K",K;
   phi, nu, alpha := EisensteinForm(Phi,K);
//"phi in EF",phi;
   vprintf Monge,2:"PolRedPadic: ramification index is %o and inertia degree is %o\n",Degree(phi)/Degree(nu),Degree(nu);
   L := Parent(alpha);
   // psi := DefiningPolynomial(L);
   if RamificationIndex(L,K) mod p ne 0 then
     M := PolRedPadicTame(phi,nu,alpha:distinguished:=distinguished,conjugates:=conjugates);
   else
//"phi",phi;
     M := PolRedPadic(phi,nu,alpha:distinguished:=distinguished,conjugates:=conjugates);
   end if;
   return M;
end intrinsic;

intrinsic PolRedPadic(Phi::RngUPolElt:distinguished:=true,conjugates:=true) -> .
{For Phi in OK irreducible return a Krasner-Monge reduced polynomial Psi such that K[x]/(Phi)=K[x]/(Psi).}
//"PolRedPadic(Phi)";
//"conjugates",conjugates;
  return PolRedPadic(Phi,CoefficientRing(Phi):conjugates:=conjugates);
end intrinsic;

intrinsic PolRedPadic(f::RngUPolElt[RngInt],p::RngIntElt:prec:=300,distinguished:=true) -> .
{
The distinguished reduced generating polynomial of the extension generated by f over Zp. 
}
  Zp := pAdicRing(p,prec);
  ZpX<X> := PolynomialRing(Zp);
  Phi := ZpX!f;
  prec := Max(SuggestedPrecision(Phi),prec);
  Zp := pAdicRing(p,prec);
  ZpX<X> := PolynomialRing(Zp);
  Phi := ZpX!f;
  Psi := PolRedPadic(Phi,Zp: distinguished:=distinguished, conjugates :=true);
  F := Polynomial(Integers(),Psi);
  return Psi;
end intrinsic;


///////////////////////////////////////////////////////////////
// Monge Reduction

intrinsic MongeReduced(f::RngUPolElt:distinguished:=true) -> .
        {
        Return the set of Monge-reduced polynomials that generate an extensions isomorphic to the extensions generated by the Eisenstein polynomial f.
}
//"MongeReduced";
/*        
        EXAMPLES

        We Monge-reduce a polynomial,.

             R := pAdicRing(3,30); Rx<x> := PolynomialRing(R);
             f := x^18+249*x^3+486*x+30;
             M := MongeReduced(f);
             M;

        If the polynomial is Monge-reduced it does not change when reduced again::

             g := Representative(M);
             N := MongeReduced(g);
             M  eq  N;

        The Monge-reduction of a polynomial generating a tamely ramified extension::

             f := x^20+249*x^3+486*x+30;
             MongeReduced(f);

        The Monge-reduction of a polynomial generating a tamely ramified extension of large degree::

             f := x^90 + 249*x^81 + 486*x^18 + 30;
             MongeReduced(f);

        We use Monge reduction to verify that two polynomials generate isomorphic extensions

             R := pAdicRing(5,200); 
             Rx<x> := PolynomialRing(R);
             f := x^25 + 15625*x^4 + 5;
             g := x^25 + 5;
             MongeReduced(f) eq MongeReduced(g);

        Monge-reduction over an unramified extensions::

             R<g> := UnramifiedExtension(pAdicRing(2,30),2); Rx<x> := PolynomialRing(R);
             f := x^8 + 66*g*x^6 + 132*g*x + 258;
             MongeReduced(f);

        Monge reduction over a totally ramified extension::

             R := pAdicRing(3,10); Rx<x> := PolynomialRing(R);
             S<a> := ext<R|x^3+9*x+3>; Sy<y> := PolynomialRing(S);
             f := y^6+6*y^2+a;
             MongeReduced(f);

        AUTHORS:

        - Sebastian Pauli and Brian Sinclair (2017-07-20): initial Sage version
        - Sebastian Pauli (2024): Magma version

        REFERENCES:

        [Mon14] M. Monge, "A family of Eisenstein polynomials
          generating totally ramified extensions, identification of extensions and
          construction of class fields." International Journal of Number Theory
          (2014): 1-29.
*/


function ramification_poly(phi);
            
        K:=CoefficientRing(phi);
        
        n:=Degree(phi);
        L:=ext<K|phi>;
        alpha:=L.1;
    
        Lx<x>:=PolynomialRing(L);
        rho:=Evaluate(phi,alpha*x + alpha) div (alpha^n); 
        rho:=Lx!rho;
        ChangePrecision(~rho,Precision(L));
    
        ramification_polygon := NewtonPolygon(rho);
      
        return ramification_polygon,rho;
end function;

function deformed_eisenstein(f, k, theta) 
          if theta eq 0 then 
            return f; 
          end if; 
          OKx<x> := Parent(f);

          OK := CoefficientRing(OKx);  
          L<alpha> := TotallyRamifiedExtension(OK,f);
          df := CharacteristicPolynomial(alpha+theta*alpha^k);
          return df;
end function;




        if not IsEisenstein(f) then
            Error("only Eisenstein polynomials can be Monge-reduced");
        end if;

        vprint Monge,2:"Monge: reduction of",f;
        n := Degree(f);
        RT<x> := Parent(f);
        R := CoefficientRing(RT);
        p := Prime(R);
        pi := UniformizingElement(R);
        F, RtoF := ResidueClassField(R);
        Fp := PrimeField(F);
        FB := Basis(F,Fp);  
        Fi := {a:a in F|IsInvertible(a)};
        q := #F;
        Fs, Fsm := UnitGroup(F);
        xi := Fsm(Fs.1); // primitive element
        xiR := R!xi;
        Fz<z> := PolynomialRing(F);
        r := F.1;

//"##################";

        function elt_coefficient(alpha,k)
          w := 0;
          while alpha ne R!0 do
            v := Valuation(alpha);
            w +:= v;
            if w gt k then
              return RtoF(0);
            end if;
            alpha := alpha/pi^v;
            albha := RtoF(alpha);
            // i := Index(rebs,albha);
            if albha ne 0 then i := discrete_log(albha); rep := R!(xi^i);
            else rep := R!0; end if;
            if w eq k then
              return albha;
            else
              //rep := reps[i];
              //rep := R!(xi^i);
              alpha := alpha-rep;
            end if;
          end while;
          return RtoF(0);
        end function;


        //  reduction step 0 -- taking care of the constant coefficient
        
        phi0 := ConstantCoefficient(f);
        phi01 := RtoF(phi0 div pi^1);
        res, M := ResidualPolynomialDistinguished(f:conjugates);
        rp, rho := ramification_poly(f);

        function hasse_herbrand(m)
          // Returns n times the (generalized) Hasse-Herbrand 
          // function of the ramification polygon R of an extension 
          // of degree n evaluated at m.
          h := Minimum([pt[2]+m*pt[1] : pt in Vertices(rp)]);
          return h;
        end function;

        function f_ij(f,m)
            lev := hasse_herbrand(m)+n;
            i := Integers()!lev  mod  n;
            j := Integers()!lev  div  n;
            fi := Coefficient(f,i);
            fij := elt_coefficient(fi,j);
            return fij, i, j;
        end function;

        J0 := Integers()!Vertices(rp)[1][2];
        a := J0 div n;
        b := J0 mod n;
        krasner_bound := 1+Floor(1+2*a+(2*b/n));   // bound on coefficents 
 
        function is_iso(S)
          FB := Basis(F,Fp);  
          FL := [Eltseq(Evaluate(S,b)):b in FB];
          FM := Matrix(FL);
          return Rank(FM) eq #FB; 
        end function;
       
        function residual_polynomial_of_component(g,m)
          rp, rho := ramification_poly(g);
          KX<X> := Parent(rho);
          K<Pi> := CoefficientRing(KX);
          G, KtoG := ResidueClassField(K);
          rhom := Evaluate(rho,Pi^m*X);
          cont := Minimum([Valuation(a) : a in Coefficients(rhom)]);
          rdpc := rhom div Pi^cont;
          Sm := &+[z^i*KtoG(Coefficient(rdpc,i)): i in [0..Degree(rdpc)]];
          return Sm;
        end function;

        // for m high enough we can set coefficients to 0       

        rpslopes := LowerSlopes(rp);
        vprint Monge,4:"Monge: slopes of ramification polygon",rpslopes; 
        intslopes := [Floor(s):s in LowerSlopes(rp)];
        intslopes := [Floor(s):s in rpslopes];
        lastlev := Integers()!-Minimum(intslopes)+1;
        h := hasse_herbrand(lastlev);
        repeat
          lastlev := lastlev-1;
          prevh := h;
          h := hasse_herbrand(lastlev);
          Sm := residual_polynomial_of_component(f,lastlev);
          isoSm := is_iso(Sm);
          vprint Monge,4:"Monge: m =",lastlev,", HasseHerbrand(m) =",h," Sm is isomorphism",isoSm,":",Sm;
        until not isoSm or not prevh-h eq 1 or lastlev eq 0;
        //until not is_iso(Sm) or not hasse_herbrand(lastlev+1)-h eq 1 or lastlev eq 0;
        //easystart := lastlev+1; 
        easystart := lastlev+1+1; 
        
        vprint Monge,1:"Monge: easy reduction starts with m =",easystart;

        function easyreduce(ff,m)
          repeat
            lev := hasse_herbrand(m)+n;
            albha, i, j := f_ij(ff,m);
            if albha ne 0 then k := discrete_log(albha); rep := R!(xi^k);
            else rep := R!0; end if;
            vprintf Monge,6:"Monge:   m = %o : setting phi_(%o,%o) = %o to 0\n",m,i,j,albha;
            fnew := (ff-rep*pi^j*x^i);
            ff := fnew;
            m := m+1;
            vprintf Monge,7:"Monge:   still isomorphic %o\n", IsIsomorphic(ff,f);
          until j ge Precision(R);
          return ff;
        end function;

        // higher reduction steps

        //vprint Monge,4:"Monge: constant coefficient processed 1",M;
        M := {easyreduce(ff,easystart):ff in M};
        //vprint Monge,4:"Monge: constant coefficient processed 2",M;
        for m in [1..easystart] do
           vprintf Monge,2:"Monge: reduction with pi -> pi + theta * pi^%o\n",m;
           new_M := {};
//"M",m,M;
           for ff in M do
              eta := -RtoF(ConstantCoefficient(ff) div pi);
              vprint Monge,2:"Monge:   reducing f =",ff;
              fij, i, j := f_ij(ff,m);
              vprint Monge,3:"Monge:   improving f_(",i,",",j,") =",fij;
              Sm  := residual_polynomial_of_component(ff,m);
              vprint Monge,3:"Monge:   Sm",Sm;
              FL := [Eltseq(Evaluate(eta^j*Sm,b)):b in FB];
              FM := Matrix(FL);
              alpha := fij;
             
              // reduce alpha by the image of eta^j*Sm 
              Mecho := EchelonForm(Matrix([Reverse(r): r in RowSequence(FM)]));
              vbeta := Vector(Reverse(Eltseq(alpha)));
              nu := 1;
              mu := 1;
              done := false;
              while nu le #FB and not done do // row counter
                while Mecho[nu][mu] eq 0 and not done do
                  if mu lt #FB then mu := mu + 1; else done := true; end if;
                end while;
                if not done then
                  vb := Vector(Mecho[nu]);
                  ab := vbeta[mu]/vb[mu];
                  vbeta := vbeta - ab*vb;
                  nu := nu + 1;
                end if;
              end while;
              beta := F!Reverse(Eltseq(vbeta));
              sol, kernel  := Solution(Matrix(FM),Vector(Eltseq(alpha-beta)));
              theta := F!Eltseq(sol);
              vprint Monge,3:"Monge:   theta",theta;
              Thetas := [theta+F!Eltseq(a):a in Set(Kernel(FM))];
              vprintf Monge,3:"Monge:   thetas %o\n",Thetas;
              new_ffs := {};
              for theta in Thetas do
                if theta eq 0 then
                  Include(~new_ffs,ff);
                else
                  vprint Monge,3:"Monge:     reduction with pi -> pi +",theta,"* pi ^",m+1;
                  def_ff := deformed_eisenstein(ff,m+1, (R!theta));
                  new_ff := easyreduce(def_ff,easystart);
                  vfij, vi, vj := f_ij(new_ff,m);
                  vprint Monge,2:"Monge:     now f_(",vi,",",vj,") =",vfij;
                  vprint Monge,3:"Monge:     reduced to",new_ff;
                  vprint Monge,5:"Monge:     test", IsIsomorphic(new_ff,f);
                  Include(~new_ffs,new_ff);
                end if;
              end for;
              new_M join:= new_ffs;
            end for;
            M := new_M;
          end for;
        if distinguished then
//"D 1";
//"M",M;
          return Distinguished(M);
        else
          return M;
        end if;
end intrinsic;


