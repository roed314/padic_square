

function ramification_poly(phi);
            
        K:=CoefficientRing(phi);
        
        n:=Degree(phi);
        L:=ext<K|phi>;
        alpha:=L.1;
    
        Lx<x>:=PolynomialRing(L);
        rho:=Evaluate(phi,alpha*x + alpha) div (alpha^n); 
        rho:=Lx!rho;
        ChangePrecision(~rho,Precision(L));
    
        ramification_polygon := NewtonPolygon(rho);
      
        return ramification_polygon,rho;
end function;

function deformed_eisenstein(f, k, theta) 
          if theta eq 0 then 
            return f; 
          end if; 
          OKx<x> := Parent(f);
          OK := CoefficientRing(OKx);  
          L<alpha> := TotallyRamifiedExtension(OK,f);
          return CharacteristicPolynomial(alpha+theta*alpha^k);
end function;

declare verbose Monge, 6;

intrinsic MongeReduced(f) -> .
        {
        Return the set of Monge-reduced polynomials that generate an extensions isomorphic to the extensions generated by the Eisenstein polynomial f.
}
/*        
        EXAMPLES

        We Monge-reduce a polynomial,.

             R := pAdicRing(3,30); Rx<x> := PolynomialRing(R);
             f := x^18+249*x^3+486*x+30;
             M := MongeReduced(f);
             M;

        If the polynomial is Monge-reduced it does not change when reduced again::

             g := Representative(M);
             N := MongeReduced(g);
             M  eq  N;

        The Monge-reduction of a polynomial generating a tamely ramified extension::

             f := x^20+249*x^3+486*x+30;
             MongeReduced(f);

        The Monge-reduction of a polynomial generating a tamely ramified extension of large degree::

             f := x^90 + 249*x^81 + 486*x^18 + 30;
             MongeReduced(f);

        We use Monge reduction to verify that two polynomials generate isomorphic extensions

             R := pAdicRing(5,200); 
             Rx<x> := PolynomialRing(R);
             f := x^25 + 15625*x^4 + 5;
             g := x^25 + 5;
             MongeReduced(f) eq MongeReduced(g);

        Monge-reduction over an unramified extensions::

             R<g> := UnramifiedExtension(pAdicRing(2,30),2); Rx<x> := PolynomialRing(R);
             f := x^8 + 66*g*x^6 + 132*g*x + 258;
             MongeReduced(f);

        Monge reduction over a totally ramified extension::

             R := pAdicRing(3,10); Rx<x> := PolynomialRing(R);
             S<a> := ext<R|x^3+9*x+3>; Sy<y> := PolynomialRing(S);
             f := y^6+6*y^2+a;
             MongeReduced(f);

        AUTHORS:

        - Sebastian Pauli and Brian Sinclair (2017-07-20): initial Sage version
        - Sebastian Pauli (2024): Magma version

        REFERENCES:

        [Mon14] M. Monge, "A family of Eisenstein polynomials
          generating totally ramified extensions, identification of extensions and
          construction of class fields." International Journal of Number Theory
          (2014): 1-29.
*/

        if not IsEisenstein(f) then
            Error("only Eisenstein polynomials can be Monge-reduced");
        end if;
        
        vprint Monge,1:"Monge: reduction of",f;
        n := Degree(f);
        RT<x> := Parent(f);
        R := CoefficientRing(RT);
        p := Prime(R);
        pi := UniformizingElement(R);
        F, RtoF := ResidueClassField(R);
        Fp := PrimeField(F);
        FB := Basis(F,Fp);  
        Fi := {a:a in F|IsInvertible(a)};
        q := #F;
        Fs, Fsm := UnitGroup(F);
        xi := Fsm(Fs.1); // primitive element
        xiR := R!xi;
        Fz<z> := PolynomialRing(F);
        r := F.1;

//"##################";

        function elt_coefficient(alpha,k)
//"eltcoeff";
          w := 0;
          while alpha ne R!0 do
            v := Valuation(alpha);
            w +:= v;
            if w gt k then
//"eltcoeff end";
              return RtoF(0);
            end if;
            alpha := alpha/pi^v;
            albha := RtoF(alpha);
            // i := Index(rebs,albha);
            if albha ne 0 then i := Log(albha); rep := R!(xi^i);
            else rep := R!0; end if;
            if w eq k then
//"eltcoeff end";
              return albha;
            else
              //rep := reps[i];
              //rep := R!(xi^i);
              alpha := alpha-rep;
            end if;
          end while;
//"eltcoeff end";
          return RtoF(0);
        end function;

        phi0 := ConstantCoefficient(f);

        //  reduction step 0 -- taking care of the constant coefficient
        
        alpha := RtoF(phi0 div pi^1);
        q := #F;
        a := Log(alpha);
/*        
        Akn := AssociativeArray();
        b := a;
        k := 0;
        repeat
          Akn[b] := k;
          b := (b+n) mod (q-1);
          k +:= 1;
"Akn",[<k,Akn[k]>: k in Keys(Akn)];
"k",k;
        until b in Keys(Akn) or k gt q-2;
"Akn",#Keys(Akn);
//"b",b;
        k1 := Akn[b];
        k2 := k;
        d  := k2-k1;
        Amin := Min(Keys(Akn));
        t := Akn[Amin];
        M := { };
//"Amin",Amin;
//"d",d;
        repeat
            theta := xi^(t);
            new_f := RT!([Coefficient(f,i)*R!theta^(n-i) : i in [0..n]]);
            Include(~M,new_f);
//"At",t;
            t +:= d;
            vprint Monge,2:"AMonge:   reduced to",new_f;
            vprintf Monge,1:"AMonge:   now f_(0,1) = %o\n", RtoF(Coefficient(new_f,0) div pi);
            vprint Monge,4:"AMonge:   test:",IsIsomorphic(new_f,f);
        until t gt q-2;

//"akn",#akn;
//"akn",akn;
        
*/
        akn := [(Integers()!a+k*n) mod (q-1):k in [0..q-2]];
        min := Min(akn);        
//"min",min;
        M := { };
        for t in [1..#akn] do
          if akn[t] eq min then 
            theta := xi^(t-1);
            new_f := RT!([Coefficient(f,i)*R!theta^(n-i) : i in [0..n]]);
            Include(~M,new_f);
//"t",t-1;
            vprint Monge,2:"Monge:   reduced to",new_f;
            vprintf Monge,1:"Monge:   now f_(0,1) = %o\n", RtoF(Coefficient(new_f,0) div pi);
            vprint Monge,4:"Monge:   test:",IsIsomorphic(new_f,f);
          end if;
        end for;

        rp, rho := ramification_poly(f);

        function hasse_herbrand(m)
//"hh";
          // Returns n times the (generalized) Hasse-Herbrand 
          // function of the ramification polygon R of an extension 
          // of degree n evaluated at m.
          h := Minimum([pt[2]+m*pt[1] : pt in Vertices(rp)]);
          return h;
        end function;

        function f_ij(f,m)
//"fij";
            lev := hasse_herbrand(m)+n;
            i := Integers()!lev  mod  n;
            j := Integers()!lev  div  n;
            fi := Coefficient(f,i);
            fij := elt_coefficient(fi,j);
            return fij, i, j;
        end function;

        J0 := Integers()!Vertices(rp)[1][2];
        a := J0 div n;
        b := J0 mod n;
        krasner_bound := 1+Floor(1+2*a+(2*b/n));   // bound on coefficents 
 
        function is_iso(S)
//"isiso";
          FB := Basis(F,Fp);  
          FL := [Eltseq(Evaluate(S,b)):b in FB];
          FM := Matrix(FL);
          return Rank(FM) eq #FB; 
        end function;
       
        function residual_polynomial_of_component(g,m)
          rp, rho := ramification_poly(g);
          KX<X> := Parent(rho);
          K<Pi> := CoefficientRing(KX);
          G, KtoG := ResidueClassField(K);
          rhom := Evaluate(rho,Pi^m*X);
          cont := Minimum([Valuation(a) : a in Coefficients(rhom)]);
          rdpc := rhom div Pi^cont;
          Sm := &+[z^i*KtoG(Coefficient(rdpc,i)): i in [0..Degree(rdpc)]];
          return Sm;
        end function;

        // for m high enough we can set coefficients to 0       

        rpslopes := LowerSlopes(rp);
        vprint Monge,4:"Monge: slopes of ramification polygon",rpslopes; 
        intslopes := [Floor(s):s in LowerSlopes(rp)];
        intslopes := [Floor(s):s in rpslopes];
        lastlev := Integers()!-Minimum(intslopes)+1;
        h := hasse_herbrand(lastlev);
        repeat
          lastlev := lastlev-1;
          prevh := h;
          h := hasse_herbrand(lastlev);
          Sm := residual_polynomial_of_component(f,lastlev);
          isoSm := is_iso(Sm);
          vprint Monge,4:"Monge: m =",lastlev,", HasseHerbrand(m) =",h," Sm is isomorphism",isoSm,":",Sm;
        until not isoSm or not prevh-h eq 1 or lastlev eq 0;
        //until not is_iso(Sm) or not hasse_herbrand(lastlev+1)-h eq 1 or lastlev eq 0;
        easystart := lastlev+1; 
        
        vprint Monge,1:"Monge: easy reduction starts with m =",easystart;

        function easyreduce(ff,m)
//"easy";
          repeat
            lev := hasse_herbrand(m)+n;
            albha, i, j := f_ij(ff,m);
            // k := Index(rebs,albha);
            if albha ne 0 then k := Log(albha); rep := R!(xi^k);
            else rep := R!0; end if;
            //rep := reps[k];
//"albha",alpha, "k",k, "rep",rep;
            //alpha := R!albha;
            //ff := (ff-rep*pi^j*x^i) mod pi^krasner_bound;
            vprintf Monge,5:"Monge:   m = %o : setting phi_(%o,%o) = %o to 0\n",m,i,j,albha;
            ff := (ff-rep*pi^j*x^i);
//"m",m,"ff",ff;
            m := m+1;
            vprintf Monge,5:"Monge:   still isomorphic %o\n", IsIsomorphic(ff,f);
          until j ge Precision(R);
          return ff;
        end function;

        // higher reduction steps

        vprint Monge,4:"Monge: constant coefficient processed 1",M;
        M := {easyreduce(ff,easystart):ff in M};
        vprint Monge,4:"Monge: constant coefficient processed 2",M;
        for m in [1..easystart-1] do
           vprintf Monge,1:"Monge: reduction with pi -> pi + theta * pi^%o",m;
           new_M := {};
           for ff in M do
              eta := -RtoF(ConstantCoefficient(ff) div pi);
              vprint Monge,2:"Monge:   reducing f =",ff;
              fij, i, j := f_ij(ff,m);
              vprint Monge,1:"Monge:   improving f_(",i,",",j,") =",fij;
              Sm  := residual_polynomial_of_component(ff,m);
              vprint Monge,1:"Monge:   Sm",Sm;
              FL := [Eltseq(Evaluate(eta^j*Sm,b)):b in FB];
              FM := Matrix(FL);
              alpha := fij;
             
              // reduce alpha by the image of eta^j*Sm 
              Mecho := EchelonForm(Matrix([Reverse(r): r in RowSequence(FM)]));
              vbeta := Vector(Reverse(Eltseq(alpha)));
              nu := 1;
              mu := 1;
              done := false;
              while nu le #FB and not done do // row counter
                while Mecho[nu][mu] eq 0 and not done do
                  if mu lt #FB then mu := mu + 1; else done := true; end if;
                end while;
                if not done then
                  vb := Vector(Mecho[nu]);
                  ab := vbeta[mu]/vb[mu];
                  vbeta := vbeta - ab*vb;
                  nu := nu + 1;
                end if;
              end while;
              beta := F!Reverse(Eltseq(vbeta));
//"eta",eta;
//"beta",beta;
//"alpha",alpha;
//"FM",FM;          
//"alpha-beta",alpha-beta;
              sol, kernel  := Solution(Matrix(FM),Vector(Eltseq(alpha-beta)));
              theta := F!Eltseq(sol);
              vprint Monge,2:"Monge:   theta",theta;
              Thetas := [theta+F!Eltseq(a):a in Set(Kernel(FM))];
              vprint Monge,2:"Monge:   thetas",Thetas;
              new_ffs := {};
              for theta in Thetas do
                if theta eq 0 then
                  Include(~new_ffs,ff);
                else
                  vprint Monge,2:"Monge:     reduction with pi -> pi +",theta,"* pi ^",m+1;
                  def_ff := deformed_eisenstein(ff,m+1, (R!theta));
                  new_ff := easyreduce(def_ff,easystart);
                  vfij, vi, vj := f_ij(new_ff,m);
                  vprint Monge,1:"Monge:     now f_(",vi,",",vj,") =",vfij;
                  vprint Monge,2:"Monge:     reduced to",new_ff;
                  vprint Monge,4:"Monge:     test", IsIsomorphic(new_ff,f);
                  // alpha, i, j := f_ij(new_ff,m);
                  Include(~new_ffs,new_ff);
                end if;
              end for;
              new_M join:= new_ffs;
            end for;
            M := new_M;
          end for;
        return M;
end intrinsic;


intrinsic Expansion(f::RngUPolElt,nu::RngUPolElt) -> .
{
  The coefficients of the nu-expansion of f as a list.
}
  expansion := [];
  l := 0;
  repeat
    l +:= 1;
    a := f mod nu;
    Append(~expansion,a);
    f := (f-a) div nu;
  until f eq 0;
  return expansion;
end intrinsic;

intrinsic Contraction(L::SeqEnum,nu::RngUPolElt) -> .
{
  Contraction(Expansion(f,nu),nu) = f
}
  return &+[L[i]*nu^(i-1) : i in [1..#L]];
end intrinsic;

intrinsic String(f::RngUPolElt,nu::RngUPolElt) -> .
{
  The nu expansion of f as a string.
}
  Zx<x> := PolynomialRing(Integers());
  nuexp := Expansion(f,nu);
  s := Sprintf("(%o)^%o + ",Zx!nu,#nuexp-1);
  for j in [1..#nuexp-2] do
    i := #nuexp-j;
    if Zx!nuexp[i] ne 0 then
      if i eq 2 then
        s cat:= Sprintf("(%o)*(%o) + ",Zx!nuexp[i],Zx!nu);
      else
        s cat:= Sprintf("(%o)*(%o)^%o + ",Zx!nuexp[i],Zx!nu,i-1);
      end if;
    end if;
  end for;
  s cat:= Sprintf("(%o)",Zx!nuexp[1]);
  return s;
end intrinsic;

intrinsic Expansion2(f::RngUPolElt,nu::RngUPolElt:limit:=0) -> .
{
  The nu-expansion of f such that its coefficients are given as p expansions and the nu-expansion of f.
}
  if limit eq 0 then limit := Precision(CoefficientRing(f)); end if;
  
  Zx<x> := PolynomialRing(Integers()); 
  nuexp := Expansion(f,nu); 
  expansion := [Zx!a : a in nuexp];
  p := Prime(CoefficientRing(nu));
  expexp := [];
  
  for g in expansion do
    h := g;
    gel := [];
    c := 0;
    while h ne 0 and c le limit do 
      Append(~gel,h mod p);
      h := h div p;
     c := c+1;
    end while;
    Append(~expexp,gel);
  end for;
  maxlen := Maximum([#gel:gel in expexp] cat [limit]); 
  for i in [1..#expexp] do 
    expexp[i] := expexp[i] cat [0:k in [1..maxlen-#expexp[i]+1]];
  end for; 
  return expexp, nuexp;
end intrinsic;

intrinsic Contraction2(L::SeqEnum,nu::RngUPolElt) -> .
{
  Contraction2(Expansion2(f,nu),nu) = f
}
  Rx<x> := Parent(nu);
  R := CoefficientRing(nu);
  p := Prime(R);
  
  return Rx!(&+[ &+[ p^(j-1)*L[i][j] : j in [1..#L[i]] ]*nu^(i-1) : i in [1..#L]]);
end intrinsic;

intrinsic Compare(f::RngUPolElt[FldFin],g::RngUPolElt[FldFin]) -> .
{
  Compare f(p) and g(p) where p is the characteristic of the coefficient ring of f and g.
}
  p := Characteristic(CoefficientRing(f));
  Z := Integers();
  Zx<x> := PolynomialRing(Z);
  Fx := Zx![a mod p : a in Coefficients(Zx!f)];
  Gx := Zx![a mod p : a in Coefficients(Zx!g)];
  F := Evaluate(Fx,p);
  G := Evaluate(Gx,p);
  return G-F;
end intrinsic;

intrinsic Distinguished(M::SetEnum[RngUPolElt[RngPad]],nu::RngUPolElt) -> .
{}  
  L := SetToSequence(M);
  p := Prime(CoefficientRing(L[1]));
  
  function dcompare(f,g)
    fexp := Expansion2(f,nu);
    gexp := Expansion2(g,nu);
    for i in [1..#fexp] do
       for k in [1..#fexp[i]] do
          fik := fexp[i][k];
          gik := gexp[i][k];
          fcp := Evaluate(fik,p);
          gcp := Evaluate(gik,p);
          if fcp ne gcp then return fcp-gcp; end if;
       end for;
    end for;
    error "compare trouble";    
    return 0;       
  end function;

  Sort(~L, dcompare);  
  return L[1];
end intrinsic;

intrinsic Compare(f::FldFinElt,g::FldFinElt) -> .
{
  Represent the finite field elements f and g by polynomials in the generator of the field over GF(p).
  Compare f(p) and g(p).
}
  Ft := PolynomialRing(Parent(f));
  return Compare(Ft!Eltseq(f),Ft!Eltseq(g));
end intrinsic;


intrinsic EisensteinForm(L::RngPad) -> .
{
  A generating polynomial of L over BaseRing(BaseRing(L)) in Eisenstein form. 
}
 
  if L eq PrimeRing(L) then
    error "EisensteinForm: L must be an extension of a local field.";
  end if;

  if BaseRing(L) eq PrimeRing(L) then
    return DefiningPolynomial(L), L.1, (PolynomialRing(BaseRing(L))).1;
  end if;

  pi := UniformizingElement(L);
  Lt<t> := PolynomialRing(L); 
  nu := DefiningPolynomial(BaseRing(L));
  gamma := Roots(Lt!nu-pi)[1][1];
  phi := CharacteristicPolynomial(gamma,BaseRing(BaseRing(L)));
  return phi, nu, gamma;
end intrinsic;


intrinsic EisensteinForm(f::RngUPolElt) -> .
{
  Given f in R[x] irreducible, return a polynomial g in Eisenstein form such that R[x]/(g) is isomorphic to R[x]/(f).
}
  if IsEisenstein(f) then
    Rx<x> := Parent(f);
    L<a> := TotallyRamifiedExtension(CoefficientRing(f),f);
    if BaseRing(L) eq PrimeRing(L) then
      return f, x, L.1;
    else
      return EisensteinForm(L);
    end if;
  end if; 
  fact, const, ext := Factorization(f:Extensions:=true);
  if #fact gt 1 then
    error "EisensteinForm: The polynomial",f,"is not irreducible";
  end if;
  Rx<x> := Parent(f);
  R := CoefficientRing(f);
//"ext",ext;
  L := ext[1]`Extension;
  
  //if BaseRing(L) eq R then 
  //  return f, L.1, x; 
  //end if;
  return EisensteinForm(L);
end intrinsic;
/* TODO 
intrinsic IsEisensteinForm(phi::RngUPolElt) -> .
{true if phi is of Eisenstein form, false otherwise}
  K := CoefficientRing(phi);
  KX<X> := Parent(phi);
  k, m := ResidueClassField(K);
  kx<x> := PolynomialRing(k);
  num := kx!phi;
  fact := Factorization(num);
  if #fact ne 1 then return false;
  else nu := KX!fact[1][1]; end if;
"nu",nu;
  nuexp := Expansion(phi,nu);
"nuexp",nuexp;
  constval :=  Min([Valuation(a):a in Coefficients(nuexp[1])]);
  leadval :=  Min([Valuation(a):a in Coefficients(nuexp[#nuexp])]);
"constval",constval;
  if constval ne 1 or leadcal ne 0 then
     return false;
  end if;
//[[Valuation(a) gt 0 : a in Coefficients(C)]:C in nuexp];
//[&and[Valuation(a) gt 0 : a in Coefficients(C)]:C in nuexp];
  otherval := &and[&and[Valuation(a) gt 0 : a in Eltseq(Coefficient(phi,i))]:i in [1..Degree(phi)-1]];
  [[Valuation(a) : a in Eltseq(Coefficient(phi,i))]:i in [1..Degree(phi)-1]];
  [[Valuation(a) gt 0 : a in Eltseq(Coefficient(phi,i))]:i in [1..Degree(phi)-1]];
  [&and[Valuation(a) gt 0 : a in Eltseq(Coefficient(phi,i))]:i in [1..Degree(phi)-1]];
"otherval",otherval;
  if not otherval then
     return false; 
  end if;
  return true;
end intrinsic;
*/
intrinsic RamificationPolyAbs(phi::RngUPolElt,alpha::RngPadElt) -> .
{Absolute ramification polygon and polynomial phi(alpha+x) of a polynomial phi in Eisenstein form,
where alpha is a root of phi.}

        L:=Parent(alpha);
        Lx<x> := PolynomialRing(L);
        rho:=Evaluate(phi,x + alpha); 
        ramification_polygon := NewtonPolygon(rho);
        return ramification_polygon,rho;
end intrinsic;

intrinsic ResidualPolynomialOfComponentAbs(phi::RngUPolElt,nu::RngUPolElt,alpha::RngPadElt,m::RngIntElt) -> .
{
The residual polynomial of the segment of the ramfication polygon of phi of slope -m and the Hasse Herbrand function of phi at m.  alpha is a root of phi and nu(alpha) a uniformizing element in the extensions generated by alpha.}
          rp, rho := RamificationPolyAbs(phi,alpha);
          KX<X> := Parent(rho);
          K := CoefficientRing(KX);
          nualpha := Evaluate(nu,alpha);
          RK, KtoRK := ResidueClassField(K);
          RKz<z> := PolynomialRing(RK);
          rhom := Evaluate(rho,nualpha^m*X);
          cont := Minimum([Valuation(a) : a in Coefficients(rhom)]);
          rdpc := rhom div nualpha^cont;
          Sm := &+[z^i*KtoRK(Coefficient(rdpc,i)): i in [0..Degree(rdpc)]];
          return Sm, cont;
end intrinsic;





intrinsic PolRedPadic(Phi::RngUPolElt,nu::RngUPolElt,alpha) -> .
        {Phi in Zp[x] in Eisenstein Form, phi(alpha)=0, nu(alpha) uniformizer of Qp(alpha), 
return all KM reductions of Phi}
       

        vprint Monge,5:"PolRedPadic: reduction of",Phi;
        
        // these stay fixed

        n := Degree(Phi);
        f := Degree(nu);
        e := n div f;
        Zpx<x> := Parent(Phi);
        Zp := CoefficientRing(Zpx);
        
        Fp, ZptoFp := ResidueClassField(Zp);
        Fps, FpstoFp := UnitGroup(Fp);
        xi := FpstoFp(Fps.1); // primitive element
        xiZp := Zp!xi;
        Fpz<z> := PolynomialRing(Fp);
        
        p := Prime(Zp);

        L := Parent(alpha);
        Lt<t> := PolynomialRing(L);
        RL, LtoRL := ResidueClassField(L);
        Pi := Evaluate(nu,alpha);        

        // these change
        
//"##################";

        function is_iso(S)
          FB := Basis(RL,Fp);  
          FL := [Eltseq(Evaluate(S,b)):b in FB];
          FM := Matrix(FL);
          return Rank(FM) eq #FB; 
        end function;

        // for m high enough we can set coefficients to 0       
       
        Wm := AssociativeArray(); // 'HasseHerbrand' of m, these do not change with phi
        rp, rho := RamificationPolyAbs(Phi,alpha);
        
        slopes := LowerSlopes(rp); // slopes := slopes[2..#slopes]; // remove infinite slope
        vprintf Monge,2: "MongeAbs: Ramification polygon %o with slopes %o\n", LowerVertices(rp), slopes;
        intslopes := [Floor(s):s in slopes | Abs(s) lt Precision(Zp)];
        
        max_m := Integers()!-Minimum(intslopes)+1;
        m := max_m;
        Sm, pre_w := ResidualPolynomialOfComponentAbs(Phi,nu,alpha,m);
        Wm[m] := pre_w;
        vprint Monge,2: "MongeAbs: m =",m,", w(m) =",Wm[m],", Sm =",Sm;
        repeat
          pre_w := Wm[m];
          m := m-1;
          Sm, Wm[m] := ResidualPolynomialOfComponentAbs(Phi,nu,alpha,m);
          vprint Monge,2: "MongeAbs: m =",m,", w(m) =",Wm[m],", Sm =",Sm;
        until not is_iso(Sm) or not Wm[m+1]-Wm[m] eq 1 or Wm[m] eq 0;
        easystart := m+1; 
        easylimit := Wm[easystart] div e + 1;
        
        vprint Monge,1:"MongeAbs: easy reduction starts with m =",easystart,"; i.e. modulo p ^",easylimit;
 
        function easyreduce(phi)
          m := easystart;
          nuexp := Expansion2(phi,nu : limit := easylimit);
          vprint Monge,4:"MongeAbs:    easy reduction start m =",easystart," modulus p ^",easylimit;
          repeat
            def, wm := IsDefined(Wm,m);
            if not def then wm := Wm[max_m]+m-max_m; end if;
            i := wm mod e;
            k := wm div e;
            nuexp[i+1][k+1] := 0;
            vprintf Monge,1:"MongeAbs:   m = %o : setting phi*_(%o,%o) = %o to 0\n",m,i,k,nuexp[i+1][k+1];
            //vprintf Monge,4:"MongeAbs:   still isomorphic %o\n", HasRoot(Lt!Contraction2(nuexp,nu));
            m := m+1;
          until k gt easylimit or k ge Precision(Zp);
          //until k ge Precision(Zp) or m ge max_m+n;
          return Contraction2(nuexp,nu);
        end function;

        vprint Monge,1:"MongeAbs: reduction with alpha -> alpha + theta * nu(alpha)";
        nuexp2, nuexp := Expansion2(Phi,nu : limit := easylimit);
        phi0 := nuexp[1];
        phi0alpha := Evaluate(phi0,alpha); 
        nualpha := Evaluate(nu,alpha);
        eta := LtoRL(nualpha^e/p);
        vprint Monge,2:"MongeAbs:   eta =",eta;              
        S1, r1 := ResidualPolynomialOfComponentAbs(Phi,nu,alpha,1);
        phi01 := RL!Evaluate(nuexp2[1][2],alpha);
        vprint Monge,2: "MongeAbs: m = 1 , w(1) =",r1,", S1 =",S1;
        vprint Monge,1:"MongeAbs:   improving phi*_(0,1) =",phi01;
        ImS1 := [<a,Evaluate(S1*eta,a)>:a in RL];
        Psi01 := [<im[1],phi01 - im[2]>: im in ImS1 | phi01-im[2] ne 0];      
        Sort(~Psi01, func<x, y | Compare(y[2],x[2])>);
        Thetas := [ a[1] : a in Psi01 | a[2] eq Psi01[1][2]];
        vprint Monge,2:"MongeAbs:   Thetas",Thetas;
        new_phis := {};
        for theta in Thetas do
          vprint Monge,2:"MongeAbs:   transformation alpha -> alpha +",theta,"* nu(alpha)";
          new_beta := alpha+(L!theta)*nualpha; 
          new_phi := CharacteristicPolynomial(new_beta,Zp);
          Include(~new_phis,<new_phi,new_beta>);
          vprint Monge,4:"MongeAbs:   now phi*_(0,1) =",Expansion2(new_phi,nu)[1][2];
        end for;
        M := new_phis;
        for m in [2..easystart] do
           vprint Monge,1:"MongeAbs: reduction with alpha -> alpha + theta * nu(alpha)^m, where m =",m;
           new_M := {};
           for phiandbeta in M do
              phi := phiandbeta[1]; beta := phiandbeta[2];
              nuexp2, nuexp := Expansion2(phi,nu : limit := easylimit);
              
              phi0 := -nuexp[1];
              phi0beta := Evaluate(phi0,beta); 
              nubeta := Evaluate(nu,beta);
              eta := LtoRL(nubeta^e/p);
              vprint Monge,2:"MongeAbs:   eta =",eta;              

              vprint Monge,5:"MongeAbs:   reducing f =",phi;
              
              Sm, wm := ResidualPolynomialOfComponentAbs(phi,nu,beta,m);
              i := wm mod e;
              k := wm div e;
              vprint Monge,1:"MongeAbs:   m =",m,", wm =",wm,", Sm =",Sm;

              phisik := nuexp2[i+1][k+1];
              vprint Monge,1:"MongeAbs:   improving phi*_(",i,",",k,") =",phisik;
              phisikbeta := LtoRL(Evaluate(phisik,beta));
              
              FB := Basis(RL,Fp);
              FL := [Eltseq(Evaluate(eta^k*Sm,b)):b in FB];
              FM := Matrix(FL);
             
              // reduce phisikbeta by the image of eta^j*Sm 
              Mecho := EchelonForm(Matrix([Reverse(r): r in RowSequence(FM)]));
              vdelta := Vector(Reverse(Eltseq(phisikbeta)));
              jB := 1;
              iB := 1;
              done := false;
              while iB le #FB and not done do // row counter
                while Mecho[iB][jB] eq 0 and not done do
                  if jB lt #FB then jB := jB + 1; else done := true; end if;
                end while;
                if not done then
                  vb := Vector(Mecho[iB]);
                  ab := vdelta[jB]/vb[jB];
                  vdelta := vdelta - ab*vb;
                  iB := iB + 1;
                end if;
              end while;
              delta := RL!Reverse(Eltseq(vdelta));
              // find coefficient for reduction
              sol, kernel  := Solution(Matrix(FM),Vector(Eltseq(phisikbeta-delta)));
              theta := RL!Eltseq(sol);
              vprint Monge,2:"MongeAbs:   theta",theta;
              Thetas := [theta+RL!Eltseq(a):a in Set(Kernel(FM))];
              vprint Monge,2:"MongeAbs:   Thetas",Thetas;
              new_phis := {};
              for theta in Thetas do
                vprint Monge,2:"MongeAbs:     transformation alpha -> alpha +",theta,"* nu(alpha) ^",m;
                new_beta := beta+(L!theta)*nubeta^m;
                new_phi := CharacteristicPolynomial(new_beta,Zp);
                Include(~new_phis,<new_phi,new_beta>);
                vprint Monge,4:"MongeAbs:     now phi*_(",i,",",k,") =",Expansion2(new_phi,nu)[i+1][k+1];
                vprintf Monge,5:"MongeAbs:     phi(beta) = phi(%o) = %o\n",new_beta,Evaluate(new_phi,new_beta);
              end for;
              new_M join:= new_phis;
            end for;
            M := new_M;
          end for;
        
        M := {easyreduce(phibeta[1]): phibeta in M};
        
        return M;

end intrinsic;


intrinsic PolRedPadic(Phi::RngUPolElt) -> .
{If Phi in K[x] is Eisenstein return the Monge reduction of Phi, where K/Qp is finite.
 If Phi in Zp[x] of Eisenstein Form, phi(alpha)=0, nu(alpha) uniformizer of Qp(alpha), return the generalized Monge reduction of Phi.}

    if IsEisenstein(Phi) then return MongeReduced(Phi); end if;

    phi, nu, alpha := EisensteinForm(Phi);
    return PolRedPadic(phi,nu,alpha);

end intrinsic;
